{
    "vf": [
        {
            "pregunta": "Tipos de datos son: \n Primitivos, estructurados, definidos por usuario y abstractos.",
            "respuesta": "V",
            "explicacion": "Los tipos de datos comúnmente utilizados son los primitivos, los estructurados, los definidos por el usuario y los abstractos.",
            "referencia": "Original",
            "id": 81
        },
        {
            "pregunta": "Tipos de datos son: \n Primitivos, estructurados, definidos por usuario y tipo lambda.",
            "respuesta": "F",
            "explicacion": "Las variables tipo lambda no existen.",
            "referencia": "Original",
            "id": 82
        },
        {
            "pregunta": "El tipo primitivo considera como datos a los enteros, los números punto flotante y caracteres.",
            "respuesta": "V",
            "explicacion": "Los datos primitivos comprenden a los enteros, los números flotantes y a los caracteres.",
            "referencia": "Original",
            "id": 83
        },
        {
            "pregunta": "El tipo primitivo considera como datos a los enteros, los números punto flotante y los strings.",
            "respuesta": "F",
            "explicacion": "Los strings son un tipo de dato estructurado.",
            "referencia": "Original",
            "id": 84
        },
        {
            "pregunta": "El tipo primitivo considera como datos a los números reales, los números punto flotante, y los caracteres.",
            "respuesta": "F",
            "explicacion": "Los números reales no pueden ser incorporados en un sistema de manera íntegra, es decir, necesitan ser aproximados para coincidir con un tipo de dato legible por la computadora.",
            "referencia": "Original",
            "id": 85
        },
        {
            "pregunta": "El tipo estructurado considera como datos a los arreglos y los registros.",
            "respuesta": "V",
            "explicacion": "Ejemplos de datos estructrados son los arreglos y los registros.",
            "referencia": "Original",
            "id": 86
        },
        {
            "pregunta": "El tipo estructurado considera como datos listas y registros.",
            "respuesta": "F",
            "explicacion": " La lista no es un dato estructurado, pues se considera como \"colección\"",
            "referencia": "Original",
            "id": 87
        },
        {
            "pregunta": "El tipo estructurado no considera a los strings como dato.",
            "respuesta": "F",
            "explicacion": "Los strings, en teoría, pueden considerarse como un arreglo de caracteres. Por lo tanto, son considerados como datos estructurados.",
            "referencia": "Original",
            "id": 88
        },
        {
            "pregunta": "El tipo ordinal incluye como datos a los enteros, los caracteres, los booleanos, los enumerados y/o los subrangos.",
            "respuesta": "V",
            "explicacion": "Ejemplos de datos ordinales son los enteros, los caracteres, los booleanos, los enumerados y los subrangos.",
            "referencia": "Original",
            "id": 89
        },
        {
            "pregunta": "El tipo ordinal incluye como datos a los enteros, los strings, los booleanos, los enumerados y/o los subrangos.",
            "respuesta": "F",
            "explicacion": "Los strings son datos estructurados.",
            "referencia": "Original",
            "id": 90
        },
        {
            "pregunta": "El tipo ordinal no incluye a los enumerados y los subrangos como datos.",
            "respuesta": "F",
            "explicacion": "Los enumerados y los subrangos son considerados como datos ordinales.",
            "referencia": "Original",
            "id": 91
        },
        {
            "pregunta": "En C y Java existen diferentes tipos de enteros tales como signed o long",
            "respuesta": "V",
            "explicacion": "El prefijo para enteros en Java y C permite otorgarles una mayor cantidad de espacio en memoria. Esto da pie a que puedan almacenar un mayor rango de números enteros.",
            "referencia": "Original",
            "id": 92
        },
        {
            "pregunta": "En C y Java existen diferentes tipos de enteros tales como float y double.",
            "respuesta": "F",
            "explicacion": "Si bien Java y C permiten estos prefijos, estos se utilizan no para números enteros sino para números flotantes.",
            "referencia": "Original",
            "id": 93
        },
        {
            "pregunta": "En C y Java existen diferentes tipos de punto flotante tales como float y double.",
            "respuesta": "V",
            "explicacion": "Java y C permiten dotar de prefijos como float y double a los números flotantes con el objetivo de que utilicen más espacio en memoria a cambio de una mejor precisión.",
            "referencia": "Original",
            "id": 94
        },
        {
            "pregunta": "Existen varias representaciones de los números enteros. Algunas conocidas son el C-1 y el C-2",
            "respuesta": "V",
            "explicacion": "Los complementos 1 y 2 son una forma de relacionar los números binarios con los enteros.",
            "referencia": "Original",
            "id": 95
        },
        {
            "pregunta": "Los números complejos son representados como punto flotante en lenguajes como Python o Prolog.",
            "respuesta": "F",
            "explicacion": "Prolog no tiene soporte para números complejos de manera nativa.",
            "referencia": "Original",
            "id": 96
        },
        {
            "pregunta": "Los números complejos son representados como punto flotante en lenguajes como Python o Scheme.",
            "respuesta": "F",
            "explicacion": "Los números complejos no son representados como punto flotante en Scheme.",
            "referencia": "Original",
            "id": 97
        },
        {
            "pregunta": "([2023-2] - Martí Q2P1) Un tipo de datos define el conjunto de valores de datos y de operaciones predefinidas sobre los objetos de datos.",
            "respuesta": "V",
            "explicacion": "Los tipos de datos son la manera de clasificar los distintas naturalezas de estos y, con ello, pueden facilitar la creación de operaciones que se pueden hacer sobre estos.",
            "id": 98
        },
        {
            "pregunta": "([2023-2] - Martí Q2P2) Un conjunto es un tipo de datos definido por el usuario.",
            "respuesta": "F",
            "explicacion": "Los conjuntos se clasifican como una colección.",
            "id": 99
        },
        {
            "pregunta": "([2023-2] - MartíQ2P3) Se llama coerción a la conversion automática de tipos.",
            "respuesta": "V",
            "explicacion": "La conversión automática de tipos de denomina coerción.",
            "id": 100
        },
        {
            "pregunta": "([2023-2] - Martí Q2P4) En una tipificación estática, los tipos solo pueden ser determinados explícitamente (declarados).",
            "respuesta": "F",
            "explicacion": "Existen lenguajes de programación donde el compilador puede deducir el tipo de dato asignado a la variable durante el tiempo de compilación.",
            "id": 101
        },
        {
            "pregunta": "([2023-2] - Martí Q2P5) En una tipificacion implícita, los tipos de datos no se declaran, y se pueden inferir a traves de reglas tal como nombre de variables a usar.",
            "respuesta": "V",
            "explicacion": "Hay lenguajes de programación, como Python, que no requiere una declaración de tipo para crear una variable.",
            "id": 102
        },
        {
            "pregunta": "([2023-2] - MartíQ2P6) Un arreglo es una colección ordenada de datos mientras que los arreglos asociativos no lo son.",
            "respuesta": "V",
            "explicacion": "Un arreglo asociativo es similar a un diccionario clave-valor, por lo que su orden es irrelevante al menos para efectos prácticos.",
            "id": 103
        },
        {
            "pregunta": "([2023-2] - Martí Q2P7) La técnica por expansión convierte un objeto a un tipo que no puede incluir todos los valores del tipo original.",
            "respuesta": "F",
            "explicacion": "La técnica que convierte un objeto a un tipo más particular que el original es estrechamiento.",
            "id": 104
        },
        {
            "pregunta": "([2023-2] - Martí Q2P8) Tanto una expresión relacional como una booleana entregan un resultado booleano, cuando el lenguaje de programación tiene este tipo de datos.",
            "respuesta": "V",
            "explicacion": "La expresiones relacionales se encargan de resolver una situación booleana. Por lo tanto, deben entregar un booleano como resultado.",
            "id": 105
        },
        {
            "pregunta": "([2023-2] - Martí Q2P9) En el paso de parámetros por valor-resultado, el valor de la variable se copia al heap al momento de la invocación y desde esta la variable al retornar.",
            "respuesta": "F",
            "explicacion": "En el paso de parámetros por valor-resultado no se utiliza el Heap.",
            "id": 106
        },
        {
            "pregunta": "([2023-2] - Martí Q2P10) En Java, todos los objetos son asignados desde el heap y accedidos mediante variables de referencia.",
            "respuesta": "V",
            "explicacion": "Java maneja los objetos por referencia y siempre desde el Heap.",
            "id": 107
        },
        {
            "pregunta": "([2022-1] - Salas Q2P4) El ámbito de una variable corresponde al tiempo de vida de una variable desde el momento que se realiza el ligado hasta el momento que se destruye o termina la variable.",
            "respuesta": "F",
            "explicacion": "El ámbito de una variable corresponde al contexto en el que es accesible por el resto del código. El tiempo de vida de la variable no está ligado a su tipo de ámbito como tal.",
            "id": 108
        },
        {
            "pregunta": "([2022-1] - Salas Q2P5) Las variables dinámicas de la memoria Heap pueden ser asignadas y liberadas en forma explícita por el programador, lo que se realiza usando un operador del lenguaje o una llamada del sistema.",
            "respuesta": "V",
            "explicacion": "Hay lenguajes como C donde el asignamiento y liberación de la memoria es manual.",
            "id": 109
        },
        {
            "pregunta": "([2022-1] - Salas Q2P6) La lápida sepulcral es un mecanismo para gestionar los punteros de la memoria Heap con el fin de evitar punteros a memoria que fue ya liberada. El acceso se realiza indirectamente a traves de una lapida y si un objeto es liberado, la lapida permanece.",
            "respuesta": "V",
            "explicacion": "La lápida sepulcral es una técnica utilizada para combatir el dangling en los punteros.",
            "id": 110
        },
        {
            "pregunta": "([2022-1] - Salas Q2P7) En el codigo ASCII de 1Byte, la letra \"A\" tiene el valor entero de 65 y la letra \"a\" tiene el valor entero \"97\". Por lo cual, el resultado de la comparacion \"F\">\"f\" es ",
            "respuesta": "F",
            "explicacion": "El valor númerico de F es menor que f en representación ASCII.",
            "id": 111
        },
        {
            "pregunta": "([2022-1] - Salas Q2P8) Un nombre puede ser asociado con diferentes direcciones de memoria en ámbitos y tiempos de ejecución diferentes. Ejemplos de tipos de datos con estas características son las uniones y los punteros en C y C++.",
            "respuesta": "V",
            "explicacion": "El contexto de un ámbito puede hacer variar la accesibilidad del resto del código a las variables dentro de este. Esta situación hace posible que se puedan \"sobreescribir\" los nombres de variables sin que el código reclame por errores.",
            "id": 112
        },
        {
            "pregunta": "([2022-1] - Salas Q2P9) El l-value indica el contenido de la variable en memoria, mientras que el r-value indica donde esta localizada la variable.",
            "respuesta": "F",
            "explicacion": "El l-value indica la localización de la variable en memoria y el r-value el contenido de esta.",
            "id": 113
        },
        {
            "pregunta": "([2022-1] - Salas Q2P10) Antes de usar una variable, se debe realizar una asociación a un tipo de dato, proceso que se conoce como ligado de tipo.",
            "respuesta": "V",
            "explicacion": "El ligado de tipo es el proceso por el cuál una variable y su contenido se asocia con algún tipo de dato.",
            "id": 114
        },
        {
            "pregunta": "([2022-1] - Salas Q2P11) En la tipificación estática, el chequeo de tipo se realiza en tiempo de compilación y se aplica solo si todos los tipos son ligados estáticamente.",
            "respuesta": "V",
            "explicacion": "Lenguajes con tipificación estática como C revisan el tipo asociado a las variables durante el tiempo de compilación.",
            "id": 115
        },
        {
            "pregunta": "([2022-1] - Salas Q2P12) Los contadores de referencias son un mecanismo de recolección de basura que consiste en marcar todos los objetos de memoria que no estan siendo utilizados y luego se libera la memoria asignada.",
            "respuesta": "F",
            "explicacion": "Los contadores de referencia guardan los punteros utilizados, más no el objeto asociado per se",
            "id": 116
        },
        {
            "pregunta": "([2022-1] - Salas Q2P13) El puntero es un tipo de dato estructurado que direcciona un espacio de memoria.",
            "respuesta": "F",
            "explicacion": "Los punteros no son datos estructurados.",
            "id": 117
        },
        {
            "pregunta": "([2022-1] - Salas Q2P14) El ligado se puede realizar de forma estática o dinámica, dependiendo si se realiza en tiempo de compilación (linking) o en tiempo de ejecución (runtime), respectivamente.",
            "respuesta": "V",
            "explicacion": "El tipo de ligado está relacionado con el contexto de su verificación, siendo el caso ya sea durante el tiempo de compilación (estático) o en el tiempo de ejecución (dinámico).",
            "id": 118
        },
        {
            "pregunta": "([2022-1] - Salas Q2P15) Las variables son una abstracción de un objeto de memoria que tienen los siguientes atributos: Nombre, Dirección, Valor, Tipo, Tiempo de Vida y Ámbito.",
            "respuesta": "V",
            "explicacion": "Las variables son la abstracción de un objeto de memoria y tiene esos atributos.",
            "id": 119
        },
        {
            "pregunta": "([2022-1] - Salas Q2P16) Una mala gestión de memoria podria generar una pérdida de acceso a un objeto de memoria asignado en el heap o podria generar punteros que apuntan a una localización de memoria del heap que ha sido liberada. Estos problemas se conocen como Basura y Danglin, respectivamente.",
            "respuesta": "V",
            "explicacion": "La mala gestión de memoria puede crear problemas durante la ejecución del programa. Estos problemas a menudo suelen ser los denominados como basura o dangling.",
            "id": 120
        },
        {
            "pregunta": "([2022-1] - Salas Q2P17) Acorde a la taxonomía de los tipos de datos, los tipos de datos ordinal pueden ser primitivos o definidos por el usuario. Los tipos de datos primitivos corresponden a los numéricos, booleanos y caracter; mientras que los definidos por el usuario estan el subrango y el enumerado.",
            "respuesta": "V",
            "explicacion": "Los tipos de datos ordinal pueden ser primitivos o definidos por el usuario.",
            "id": 121
        },
        {
            "pregunta": "([2022-1] - Salas Q2P18) La memoria se clasifica en: Memoria Estática, Memoria de Stack y Memoria de Heap. En las memorias estaticas y de Stack el ligado es estático, mientras que en la memoria heap el ligado es dinámico.",
            "respuesta": "F",
            "explicacion": "El tipo de ligado va asociado con el contexto donde ocurre su verificación, no en el tipo de memoria donde esté declarada su dato respectivo.",
            "id": 122
        },
        {
            "pregunta": "([2022-1] - Díaz Q2P1) La tipificación fuerte ocurre cuando se determina el tipo de todas las variables antes de la ejecución, y luego permanece fijo.",
            "respuesta": "F",
            "explicacion": "La tipificación fuerte se encarga de restringir las operaciones inválidas entre tipos incompatibles. Esta clasificación no está relacionada con el contexto de la verificación de tipo.",
            "id": 123
        },
        {
            "pregunta": "([2022-1] - Díaz Q2P2) En Python, los enteros y strings son pasados por paso valor.",
            "respuesta": "F",
            "explicacion": "Python utiliza el paso por referencia.",
            "id": 124
        },
        {
            "pregunta": "([2022-1] - Díaz Q2P3) Las colas, stacks y diccionarios corresponden a tipos de datos de la categoria colecciones ordenadas.",
            "respuesta": "F",
            "explicacion": "Un diccionario es una colección no ordenada.",
            "id": 125
        },
        {
            "pregunta": "([2022-1] - Díaz Q2P4) La definición de trasparencia referencial es: \"dos tipos de datos son equivalentes si el operando de un tipo en una expresión puede ser sustituido por otro de manera explícita\".",
            "respuesta": "F",
            "explicacion": "La transparencia referencial es una característica de las funciones puras que está ligada a que una función siempre va a entregar el mismo resultado con los mismos argumentos. No está relacionada con lo que dice el enunciado.",
            "id": 126
        },
        {
            "pregunta": "([2022-1] - Díaz Q2P5) El for en C es un ejemplo de bucles controlados por condición.",
            "respuesta": "F",
            "explicacion": "El for en C y en otros lenguajes corresponde a un bucle controlado por contador.",
            "id": 127
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P1) Un sistema de tipos de datos permite verificar el uso correcto del lenguaje y detectar errores de tipos solo en lenguajes compilados.",
            "respuesta": "F",
            "explicacion": "Los lenguajes interpretados también pueden detectar problemas de ligado de tipo.",
            "id": 128
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P2) La coerción, definida por el programador, ayuda a tener operaciones con operandos de tipos compatibles.",
            "respuesta": "F",
            "explicacion": "La coerción es una conversión de tipos automática exclusiva del lenguaje, no del programador.",
            "id": 129
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P3) En la equivalencia de tipo nominal, los tipos pueden tener nombres distintos pero una estructura idéntica.",
            "respuesta": "F",
            "explicacion": "La equivalencia de tipo nominal revisa si dos tipos tienen el mismo nombre, mas no si tienen la misma estructura.",
            "id": 130
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P4) La tipificación de datos estática permite el interprete asignar memoria y generar código optimizado.",
            "respuesta": "F",
            "explicacion": "La tipificación estática solo determina el contexto donde se verifica el ligado de tipo.",
            "id": 131
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P5) Según el estándar IEEE 754, la representación de un número flotante considera tres partes: signo, parte entera y parte decimal de 23 o 52 bits, según corresponde a su precisión.",
            "respuesta": "F",
            "explicacion": "El estándar IEEE 754 considera el signo (1b), el exponente (8b) y la mantisa (23b).",
            "id": 132
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P6) Los tipos subrango se implementan en base al tipo entero.",
            "respuesta": "V",
            "explicacion": "Los tipos subrango tienen como base un conjunto de números enteros.",
            "id": 133
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P7) En las dos modalidades de arreglos dinámicos de stack, la memoria del arreglo es ligada de forma dinámica.",
            "respuesta": "F",
            "explicacion": "La memoria de un arreglo es ligada dinámicamente cuando es un arreglo creado en la memoria Heap.",
            "id": 134
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P8) El tipo referencia es un tipo de variable que realiza desreferenciación implícita en la asignación, por lo que su uso es más seguro.",
            "respuesta": "V",
            "explicacion": "El tipo referencia permite apuntar directamente a un objeto en particular dentro de la memoria, por lo que en un uso correcto garantiza la manipulación completa de este objeto y no de cualquier otro.",
            "id": 135
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P9) El problema de dangling se presenta cuando un puntero apunta a una localizacion de memoria del heap que ha sido liberada.",
            "respuesta": "V",
            "explicacion": "El dangling ocurre cuando un puntero sigue apuntando a una localización de memoria que ha sido previamente liberada.",
            "id": 136
        },
        {
            "pregunta": "([2024-2] - José Luis Martí. Q2P10) Si solo se hace referencia a variables locales, no hay presencia de efectos laterales en las expresiones de control.",
            "respuesta": "V",
            "explicacion": "Los efectos laterales surgen a partir del choque entre variables con distinto ámbito.",
            "id": 137
        },
        {
            "pregunta": "([2021-x] José Luis Martí C1P5 MOD) Si las patentes vehiculares en chile se pueden describir por la expresion regular \n^[A-Z]{2}\\.[0-9]{2}\\.[0-9]{2}$\n, para anteponer un digito obligatorio se tendria que usar la expresion /^[1-9]*\\ al inicio.",
            "respuesta": "F",
            "explicacion": "El asterisco en la modificación hace que el dígito se pueda omitir.",
            "id": 138
        },
        {
            "pregunta": "([2021-x] José Luis Martí C1P6) En un proceso de compilación, la tabla de simbolos ayuda a resolver las ambigüedades de los arboles sintáticos",
            "respuesta": "F",
            "explicacion": "La ambigüedad de los árboles sintácticos solo se pueden arreglar mejorando el diseño de la gramática que representan.",
            "id": 139
        },
        {
            "pregunta": "([2021-x]  José Luis Martí C1P7) La trasparencia referencial se refiere a que la evaluación de una función siempre produce el mismo resultado.",
            "respuesta": "V",
            "explicacion": "La transparencia referencial está ligada con el comportamiento de una función pura, siendo el caso que se cumpla que mismos argumentos siempre darán un mismo resultado.",
            "id": 140
        },
        {
            "pregunta": "([2021-x]  José Luis Martí C1P8) Una de las desventajas de la declaración implícita de los tipos de datos, es que hace mas lenta la ejecucion debido a la verificación dinámica de estos.",
            "respuesta": "V",
            "explicacion": "Si bien la declaración implícita le otorga mayor flexibilidad al programador, el tiempo que toma la verificación del código es mayor por todas las nuevos factores que el intérprete o compilador debe revisar.",
            "id": 141
        }
    ],
    "alt": [
        {
            "pregunta": "\nConsiderando la Taxonomia de tipos de datos, se pueden clasificar segun:\n    I. Estatica o dinamica\n    II. Explicita o implicita\n    III- Primitivos o operadores\n    IV. Fuerte o debil\n    \na. Solo III\nb. Solo I y II\nc. Solo I, II y III\nd. Todas las anteriores.\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1048,
            "intAnswers": 4
        },
        {
            "pregunta": "\nEn la conversion de tipos, se pueden presentar diversos errores, siendo uno de ellos:\na. Efecto lateral.\nb. Division por cero.\nc. dangling\nd. Ambiguedad\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1049,
            "intAnswers": 4
        },
        {
            "pregunta": "\nConsiderando la Taxonomia de tipo de datos, cuales de las siguientes son verdad\n    I. Estatica es cuando se declara el tipo de dato de las variables, mientras que dinamico se determina en la ejecucion\n    II. Explicita indica que todo se debe declarar, mientras que implicita no se requiere declaracion\n    III. Tipificacion fuerte es generealmente mas restrictiva, a diferencia de la debil que permite mas flexibilidad\n    IV. Es obligatorio que el sistema sea: Estatico, explicito y fuerte, o dinamico, implicito, y debil.\na. Solo I, II\nb. Solo II y III\nc. Solo I, II, y IV\nd. Todas las anteriores\n\n",
            "respuesta": "c",
            "explicacion": " Notar que, no es obligatorio. Generalmente se apoyan",
            "referencia": "Original",
            "id": 1050,
            "intAnswers": 4
        },
        {
            "referencia": "[2023-2] - Martí Q2P11",
            "pregunta": "\nEn el lenguaje de programacion C, dado un arreglo A de 10 enteros, ¿cual(es) de los siguientes expresiones es(son) equivalente(s) para obtener el elemento ubicado en la quinta posicion?\n    I. A[5]\n    II. A[4]\n    III. *    IV.  *a. Solo I\nb. Solo II\nc. Solo I y IV\nd. Solo II y III\n\n",
            "respuesta": "d",
            "explicacion": "Ni yo sabia de la III...",
            "id": 1051,
            "intAnswers": 4
        },
        {
            "referencia": "[2023-2] - Martí Q2P12",
            "pregunta": "\nUn metodo de recoleccion de basura impaciente:\n    I. Acumula basura hasta que se agota la memoria. x\n    II. Us aun contador de referencias\n    III. Se decrementa un contador cuando se pierde una referencia\n    IV. Puede producir tiempos muertos significativos que afectan al funcionamiento del programa\n    \na. Solo I y II\nb. Solo I, II y III\nc. Solo II y III\nd. Solo II, III y IV\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1052,
            "intAnswers": 4
        },
        {
            "referencia": "[2023-2] - Martí Q2P13",
            "pregunta": "\nSe produce dangling cuando una celda en el heap:\na. Tiene referencias y esta marcada correctamente como libre por el administrador de memoria.\nb. Tiene al menos una referencia y esta asignada, es decir, marcada correctamente por el administrador como ocupada\nc. No tiene referencia y no esta marcada como libre, por ende, el administrador no la puede reasignar\nd. Tiene alguna referencia y esta marcada como libre, luego el administrador la podria reasignar\n\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1053,
            "intAnswers": 4
        },
        {
            "referencia": "[2023-2] - Martí Q2P14",
            "pregunta": "\nCual de los siguientes pares de funciones en C++ son un ejemplo de sobrecargar de funciones?\n\na. ```c \n{\n    int f(int a, int b){...}\n    int f(int x, int y){...}\n}\n ``` \nb. ```c \n{\n    int f(int a, int b){...}\n    int f(int a, int b, int c){...}\n}\n ``` \nc. ```c \n{\n    int f(int a, int b){...}\n    int g(int a, int b){...}\n}\n ``` \nd. ```c \n{\n    int f(int a, int b){...}\n    int g(int a, int b, int c){...}\n}\n ``` \n\n",
            "respuesta": "b",
            "explicacion": " Recordar que la sobrecarga es funcion con mismo nombre pero recibe distinta cantidad de parametross",
            "id": 1054,
            "intAnswers": 4
        },
        {
            "referencia": "[2023-2] - Martí Q2P15",
            "pregunta": "\nDado el siguiente codigo en C:\n\n    ```c \nint x;\n    void f    {\n        a = 2;\n        x++;\n    }\n    void main    {\n        x = 1;\n        f(x);\n        printf(\"%d\",x);\n    }\n ```    \n¿Cual sera el resultado del printf() si el parametro hubiera sido pasado por valor-resultado y por referencia, respectivamente?\na. por Valor-resultado; 2, por Referencia; 1.\nb. por Valor-resultado; 3, por Referencia; 3.\nc. por Valor-resultado; 2, por Referencia; 2.\nd. por Valor-resultado; 2, por Referencia; 3.\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1055,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Salas Q2P19",
            "pregunta": "\n\nLa siguiente definicion...\n    \"Es un tipo estructurado de elementos de datos posiblemente heterogeno, donde cada elemento individual es identificado con un nombre\".\n\nCorresponde a una definicion de:\na. Registro\nb. Enumerado\nc. Diccionario\nd. Array\n\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1056,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Salas Q2P20",
            "pregunta": "La siguiente definicion...\n    \"Es un tipo estructurado que permite almacenar diferentes tipos de datos en diferentes tiempo de una misma variable\".\n\nCorresponde a una definicion de:\na. Lista\nb. Uniones\nc. Subrango\nd. Arreglo\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1057,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Salas Q2P21",
            "pregunta": "La siguiente definicion...\n    \"Es un tipo de dato ordinal definido por el usuario que consiste en una subsecuencia contigua de un tipo ordinal ya definido\".\n\nCorresponde a una definicion de:\na. Lista\nb. Arreglo\nc. Subrango\nd. Diccionario\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1058,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Salas Q2P23",
            "pregunta": "La siguiente definicion...\n    \"Corresponde a tipos de datos que no estan definidos en terminos de otros tipos\".\n\nCorresponde a una definicion de:\na. Caracter\nb. Ordinal\nc. Estructurado\nd. Primitivo\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1059,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Salas Q2P23",
            "pregunta": "Tipos de datos ordinales son...\n    I. Caracter\n    II. Booleano\n    III. Numerico\na. Solo I\nb. Solo I y III\nc. Solo II y III\nd. Todas las anteriores    \n\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1060,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Salas Q2P25",
            "pregunta": "La siguiente definicion...\n    \"Es un tipo de dato estructurado que corresponde a una secuencia de caracteres usado para procesamiento de texto y para E/S\".\n\nCorresponde a una definicion de:\na. UTF-8\nb. String\nc. Arreglo\nd. punto flotante\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1061,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Salas Q2P26",
            "pregunta": "La siguiente definicion...\n    \"Es un tipo de dato ordinal definido por el usuario donde se enumeran todos los posibles valores a traves de constantes literales. Se establece una relacion de orden\".\n\nCorresponde a una definicion de:\na. Diccionario\nb. Hash\nc. Enumerado\nd. Arreglo\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1062,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Salas Q2P26",
            "pregunta": "La siguiente definicion...\n    \"Es un tipo de dato estructurado que agrupa conjunto de elementos (que pueden ser de diferentes tipos), con operadores para construirlos y acceder a sus elementos. Existen de dos tipos: Ordenadas y No Ordenadas\".\n\nCorresponde a una definicion de:\na. Enumerados\nb. Relaciones de orden\nc. Lista\nd. Colecciones\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1063,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Diaz Q2P2 alt",
            "pregunta": "\nCual de los siguientes tipos de datos esta mal clasificado?\n\na. Arreglo: tipo estructurado\nb. String: tipo primitivos\nc. Enumerado: tipo definido por el usuario\nd. Conjunto: tipo estructurado\n\n",
            "respuesta": "b",
            "explicacion": " Caracter es primitivo, no string",
            "id": 1064,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Diaz Q2P3 alt",
            "pregunta": "\nUna variable declarada como int a[20] dentro de una funcion C, corresponde a un arreglo:\n\na. Estatico\nb. Dinamico de heap.\nc. Dinamico fijo de stack.\nd. Fijo de heap\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1065,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Diaz Q2P4 alt",
            "pregunta": "\n¿Cual de los sigientes elementos no es parte de la estructura de registro de activacion de un subprograma?\n\na. Variables globales\nb. Variables locales\nc. Direccion de retorno\nd. Enlace dinamico\n\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1066,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Diaz Q2P5 alt",
            "pregunta": "\nAl clasificar las sentencias de iteracion, una de las siguientes posibilidades no es una forma real de controlar un ciclo... ¿Cual es?\n\na. Por contador\nb. Por condicion\nc. Por alternativa\nd. Por estructura de datos\n\n",
            "respuesta": "c",
            "explicacion": " Alternativa no es algo bien definido. Por estructura de datos si se puede, considere el for x in lista de python",
            "id": 1067,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Diaz Q2P6 alt",
            "pregunta": "\nUn arreglo asociativo es...\n\na. Conjunto ordenado de elementos de datos, que son accesados via referencias\nb. Conjunto no ordenado de elementos de datos, que son indexados por igual numero de valores, llamados \"claves\".\nc. Conjunto no ordenado de elementos de datos, que se identifican por su posicion relativa mediante un indice.\nd. Conjunto ordenado de elementos de datos, donde el tamaño permanece fijo una vez creado.\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1068,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q2P11",
            "pregunta": "\n\nEn Java, que tipo de strings se manejan?\na. Estaticos\nb. Dinamicos limitados\nc. Dinamicos\nd. Todos los anteriores\n\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1069,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q2P12",
            "pregunta": "\nEn el lenguaje de programacion C, dado un arreglo A de 10 enteros, cual(es) de las siguientes expresiones es(son) equivalente(s) para obtener el elemento ubicado en la quinta posicion?\n    I. A[5]\n    II. A[4]\n    III. *A+4\n    IV. *A+5\na. Solo I\nb. Solo II\nc. Solo I y IV\nd. Solo II y III\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1070,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q2P13",
            "pregunta": "\nCual de los siguientes operaciones no es permitida en Python, sobre la base de que a y b son del tipo conjunto?\na. c = a|b \nb. c = a&b \nc. c = a-b\nd. c = a*b\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1071,
            "intAnswers": 4
        },
        {
            "pregunta": "\n([2021]  Jose Luis Marti C1P24) \nCuales de las siguientes frases son ciertas sobre un metodo de recoleccion de basura impaciente?\n    I. Se ejecuta tan pronto se agota la memoria\n    II. Usa un contador de referencias\n    III. Se decrementa un contador cuando se pierde una referencia\n    IV. Requiere de mayor tiempo de ejecucion y uso de memoria que un recolector perezoso\na. I y II\nb. I, II y III\nc. II y IV\nd. II, III y IV\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1072,
            "intAnswers": 4
        },
        {
            "referencia": "[2021]  Jose Luis Marti C1P25",
            "pregunta": "\nEn que situacion la instruccion malloc() de C podria generar un stack overflow?\na. Un ciclo b. Una funcion recursiva mal programada\nc. Una lista de nodos que crecio sin control \nd. Nunca\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1073,
            "intAnswers": 4
        },
        {
            "referencia": "[2021]  Jose Luis Marti C1P26",
            "pregunta": "\nEn la siguiente funcion de C, es cierto que:\n\n   ```c \n char *f    {\n        static int k = 0\n        int a = strlen        char *p = malloc        \n        return p ? strcpy(p, s+k): NULL;\n    }\n ``` \na. a es una variable de stack y s una de heap\nb. k es una variable estatica, y p una de heap\nc. a es una variable de stack, y *p una de heap\nd. a es una variable de heap y p una de heap\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1074,
            "intAnswers": 4
        },
        {
            "referencia": "[2021]  Jose Luis Marti C1P27",
            "pregunta": "\nTomar en cuenta el siguiente programa escrito en sintaxis tipo Javascript\n\n    ```js \n// main\n    var x,y,z;\n    \n    function sub1() {\n        var a, y, z;\n        ...\n    }\n    \n    function sub2() {\n        var a, b, z;\n        ...\n    }\n    \n    function sub3() {\n        var a, x, w;\n        ...\n    }\n ```    \nDada la siguiente secuencia en un ambito dinamico: main -> sub1() -> sub3() -> sub2(), cuales son todas las variables durante la ejecucion de sub2?\n\na. a local, b local, x de main, y de main, z local\nb. a local, b local, x de main, y de sub1(), z local\nc. a local, b local, z local\nd. a local, b local, w de sub3(), x de sub3(), y de sub1(), z local\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1075,
            "intAnswers": 4
        },
        {
            "referencia": "[2021]  Jose Luis Marti C1P28",
            "pregunta": "\n\nCual de las siguientes afirmaciones no es correcta, dependiendo del tipo de paso por parametros?\n\n  ```c \nvoid f    {\n        a = 1;\n        b++;\n    }\n    \n    int main    {\n        int i = 10;\n        int j = 20;\n        \n        f(i,j);\n        printf(\"%d $d\", i, j);\n    }\n ```    \na. Por resultado, la salida de printf() de la funcion main() es: 10 20\nb. Por referencia, la salida del printf() de la funcion f() es: 1 21\nc. Por valor, la salida del printf() de la funcion main() es: 10 20\nd. Por valor-resultado, la salida del printf() de la funcion f() es: 1 21\n\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1076,
            "intAnswers": 4
        }
    ]
}
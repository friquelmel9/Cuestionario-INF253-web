{
    "vf": [
        {
            "pregunta": "En los paradigmas de la programación, el paradigma imperativo es aquel centrado en la ejecución secuencial. Enfoques relacionados a este paradigma son el procedural y el Orientado a Objetos.",
            "respuesta": "V",
            "explicacion": "El paradigma de programación imperativo se basa en un conjunto de instrucciones predefinidas en cada código que se ejecutan de manera secuencial. Dentro de los enfoques relacionados se encuentra el procedural y el Orientado a Objetos porque ambos se codifican pensando en cómo debe proceder el programa.",
            "referencia": "Original",
            "id": 1
        },
        {
            "pregunta": "En los paradigmas de la programación, el paradigma imperativo es aquel donde se define el cómo se deben hacer las cosas dentro del código.",
            "respuesta": "V",
            "explicacion": "El paradigma imperativo de la programación está basado en código que posea secuencias de instrucciones precisas y bien definidas, por lo que es necesario programar pensando desde el cómo hacer las cosas.",
            "referencia": "Original",
            "id": 2
        },
        {
            "pregunta": "En los paradigmas de la programación, el paradigma declarativo es aquel en el que se define qué se quiere hacer con el programa. Sus enfoques son el funcional y el lógico",
            "respuesta": "V",
            "explicacion": "El paradigma declarativo se basa, como su nombre lo indica, en declaraciones que pretenden obtener lo que se espera con una instrucción en particular. Los programas creados bajo este paradigma como los que comúnmente se ven en el enfoque funcional y el lógico se hacen pensando más en la obtención del objetivo final que en la manera en la que se debe obtener.",
            "referencia": "Original",
            "id": 3
        },
        {
            "pregunta": "En los paradigmas de la programación, el paradigma declarativo es aquel que se construye a través de código que se ejecuta de manera secuencial.",
            "respuesta": "F",
            "explicacion": "El paradigma declarativo se centra en el qué se debe hacer, por lo que la riqueza del código no está pensada para ser ejecutada de manera secuencial por medio de instrucciones precisas.",
            "referencia": "Original",
            "id": 4
        },
        {
            "pregunta": "Ejemplos de lenguajes procedural son Fortran, Algol, Pascal y C.",
            "respuesta": "V",
            "explicacion": "Estos ejemplos de lenguajes se basan en la utilización de bloques de código llamados funciones o procedimientos que permiten la creación de programas bajo un enfoque imperativo.",
            "referencia": "Original",
            "id": 5
        },
        {
            "pregunta": "Ejemplos de lenguajes procedural son Fortran, Algol, Pascal y C++.",
            "respuesta": "F",
            "explicacion": "C++ no es un lenguaje procedural, sino un lenguaje mayormente Orientado a Objetos.",
            "referencia": "Original",
            "id": 6
        },
        {
            "pregunta": "Ejemplos de lenguajes Orientados a Objetos son SmallTalk, C++ y Java.",
            "respuesta": "V",
            "explicacion": "Todos estos lenguajes funcionan bajo la premisa del uso de objetos y todas las características que los rodean.",
            "referencia": "Original",
            "id": 7
        },
        {
            "pregunta": "Ejemplos de lenguajes Orientado a Objetos son Algol, C++ y Java.",
            "respuesta": "F",
            "explicacion": "Algol es un lenguaje con enfoque procedural.",
            "referencia": "Original",
            "id": 8
        },
        {
            "pregunta": "Ejemplos de lenguajes funcionales son LISP, Scheme y Haskell.",
            "respuesta": "V",
            "explicacion": "Estos lenguajes pertenecen al enfoque funcional porque trabajan teniendo presente la inmutabilidad de las variables y la naturaleza pura de las funciones matemáticas.",
            "referencia": "Original",
            "id": 9
        },
        {
            "pregunta": "Ejemplos de lenguajes funcionales son LISP, Scheme y Prolog.",
            "respuesta": "F",
            "explicacion": "Prolog es un lenguaje con enfoque lógico, no funcional.",
            "referencia": "Original",
            "id": 10
        },
        {
            "pregunta": "Ejemplos de lenguajes lógicos son Prolog y LISP.",
            "respuesta": "F",
            "explicacion": "LISP es un lenguaje con enfoque funcional.",
            "referencia": "Original",
            "id": 11
        },
        {
            "pregunta": "La sintaxis de un lenguaje de programación es la descripción precisa de todos los programas gramaticalmente correctos.",
            "respuesta": "V",
            "explicacion": "La sintaxis de una sentencia radica en si esta o no cumple con lo propuesto en la grámatica del lenguaje en particular.",
            "referencia": "Original",
            "id": 12
        },
        {
            "pregunta": "La sintaxis de un lenguaje de programación puede ser definida mediante BNF.",
            "respuesta": "V",
            "explicacion": "Backus-Naur Form (BNF) es una notación especial creada para describir gramáticas de libre contexto. Estas gramáticas permiten el poder crear expresiones regulares, lo que lógicamente permite describir la sintaxis de un lenguaje.",
            "referencia": "Original",
            "id": 13
        },
        {
            "pregunta": "La sintaxis de un lenguaje de programación puede ser definida mediante expresiones regulares, mas no por BNF.",
            "respuesta": "F",
            "explicacion": "La notación de Backus-Naur describe gramáticas de libre contexto que permiten la presencia de expresiones regulares, por lo que la sintaxis de un lenguaje puede ser descrita mediante BNF.",
            "referencia": "Original",
            "id": 14
        },
        {
            "pregunta": "La sintaxis de un lenguaje establece la estructura de una sentencia, mas no su significado.",
            "respuesta": "V",
            "explicacion": "El área encargada de evaluar el significado de una sentencia es la semántica.",
            "referencia": "Original",
            "id": 15
        },
        {
            "pregunta": "La sintaxis de un lenguaje establece el significado de una sentencia, mas no su estructura.",
            "respuesta": "F",
            "explicacion": "La sintaxis describe la estructura de una sentencia mediante la gramática definida.",
            "referencia": "Original",
            "id": 16
        },
        {
            "pregunta": "La semántica de un lenguaje está relacionada con el significado de las sentencias presentes en este a diferencia de la sintaxis.",
            "respuesta": "V",
            "explicacion": "La semántica radica en el significado de las expresiones del lenguaje y la sintaxis en las estructuras en las que estas son descritas.",
            "referencia": "Original",
            "id": 17
        },
        {
            "pregunta": "La semántica de un lenguaje está ligada con la estructura del lenguaje y el significado lo está con la sintaxis.",
            "respuesta": "F",
            "explicacion": "La semántica está relacionada con el significado y la sintaxis con la estructura.",
            "referencia": "Original",
            "id": 18
        },
        {
            "pregunta": "Backus-Naur Form (BNF) es un metalenguaje creado para especificar gramáticas libre de contexto.",
            "respuesta": "V",
            "explicacion": "La notación BNF está hecha para describir gramáticas libres de contexto.",
            "referencia": "Original",
            "id": 19
        },
        {
            "pregunta": "Backus-Naur Form (BNF) es un metalenguaje creado para especificar lenguajes regulares.",
            "respuesta": "F",
            "explicacion": "La notación BNF está hecha para describir gramáticas libres de contexto.",
            "referencia": "Original",
            "id": 20
        },
        {
            "pregunta": "Las expresiones regulares permiten describir patrones de cadenas de caracteres útiles para reconocer tokens.",
            "respuesta": "V",
            "explicacion": "Las expresiones regulares se utilizan para verificar la sintaxis, por lo que sirven para identificar patrones y tokens.",
            "referencia": "Original",
            "id": 21
        },
        {
            "referencia": "[2021-2] - Martí Q1P1",
            "pregunta": "Un ámbito estático es determinado analizando código fuente.",
            "respuesta": "V",
            "explicacion": "El ámbito estático se genera durante el tiempo de compilación. Por lo tanto, necesita revisar el código fuente.",
            "id": 22
        },
        {
            "referencia": "[2021-2] - Martí Q1P2",
            "pregunta": "Prolog es un lenguaje funcional que incorpora elementos de programación imperativa.",
            "respuesta": "F",
            "explicacion": "Prolog es un lenguaje lógico que NO incorpora elementos de programación imperativa.,",
            "id": 23
        },
        {
            "referencia": "[2021-2] - Martí Q1P3",
            "pregunta": "Uno de los tipos de ámbitos para subprogramas es permitir el anidamiento de estos, definiendo una ascendencia de tipo dinámico en tiempo de ejecución.",
            "respuesta": "F",
            "explicacion": "El anidamiento de subprogramas hace referencia a la capacidad de poder definir funciones dentro de procedimientos más grandes. Se dice que es dinámico en tiempo de ejecución porque permite que la función interna pueda acceder a lo definido en la función exterior de manera dinámica, pues depende del contexto en el que se invocó a esta última.",
            "id": 24
        },
        {
            "referencia": "[2021-2] - Martí Q1P4",
            "pregunta": "Una definición especifica el nombre de la variable y liga tipo, entre otros atributos, pero no asigna memoria.",
            "respuesta": "F",
            "explicacion": "La definición de una variable sí asigna memoria.",
            "id": 25
        },
        {
            "referencia": "[2021-2] - Martí Q1P5",
            "pregunta": "Las variables dinámicas de heap pueden ser manipuladas en forma implícita o explícita, dependiendo del lenguaje.",
            "respuesta": "V",
            "explicacion": "La manipulación de variables dinámicas de heap está relacionada con la gestión de memoria que utiliza el lenguaje. En casos como Java, la gestión del heap es automática (o ímplicita, si se prefiere) mientras que, por ejemplo, en C, la gestión es manual (o explícita).",
            "id": 26
        },
        {
            "referencia": "[2021-2] - Martí Q1P6",
            "pregunta": "C es un lenguaje imperativo que permite elementos de la programación lógica.",
            "respuesta": "F",
            "explicacion": "C no permite elementos de la programación lógica.",
            "id": 27
        },
        {
            "referencia": "[2021-2] - Martí Q1P8",
            "pregunta": "Un ámbito global define una estructura del programa como una secuencia de definiciones de funciones donde las variables pueden aparecer definidas fuera de ellas.",
            "respuesta": "V",
            "explicacion": "Es posible definir variables dentro de un contexto global que pueden ser vistas por las definiciones de funciones con un contexto independiente.",
            "id": 28
        },
        {
            "referencia": "[2021-2] - Martí Q1P9",
            "pregunta": "El proceso de compilación sigue las siguientes etapas: \n```Análisis Léxico --> Análisis Semántico --> Análisis Sintáctico --> Generación de Código```",
            "respuesta": "F",
            "explicacion": "A grandes rasgos, el proceso de compilación sigue este orden: Análisis Léxico -->  Análisis Sintáctico --> Análisis Semántico --> Generación de Código",
            "id": 29
        },
        {
            "referencia": "[2021-2] - Martí Q1P10",
            "pregunta": "Python es un lenguaje scripting que permite la orientación a objetos.",
            "respuesta": "V",
            "explicacion": "Python es un lenguaje multiparadigma que permite la OO.",
            "id": 30
        },
        {
            "referencia": "[2021-2] - Martí Q1P11",
            "pregunta": "En la modalidad de compilación separada, las unidades de programas pueden compilarse en diferentes tiempos, pero considerando las dependencias entre ellas.",
            "respuesta": "V",
            "explicacion": "La compilación separada se basa en la división del código fuente en varios archivos de códigos más pequeños. Es necesario que se considere las dependencias entre archivos para poder aprovechar lo que la modalidad permite.",
            "id": 31
        },
        {
            "referencia": "[2021-2] - Martí Q1P13",
            "pregunta": "La memoria del heap permite mantener objetos que se asignan y liberar automáticamente al activar o desactivar un ambiente de ejecución.",
            "respuesta": "F",
            "explicacion": "Ciertos lenguajes, como C, necesitan que se indique la liberación de memoria de manera manual.",
            "id": 32
        },
        {
            "referencia": "[2021-2] - MartíQ1P15",
            "pregunta": "Java y C# son lenguajes de programación que usan una máquina virtual para interpretar directamente el código fuente durante su ejecución.",
            "respuesta": "F",
            "explicacion": "Java y C# son lenguajes híbridos que si bien interpretan código, primero necesitan transformarlo a un código intermedio con una compilación previa.",
            "id": 33
        },
        {
            "referencia": "[2021-2] - Martí Q1P16",
            "pregunta": "Las variables dinámicas de stack son ligadas a memoria en el momento que la ejecución alcanza el código ligado a la declaración.",
            "respuesta": "V",
            "explicacion": "Las variables dinámicas de stack están presentes del contexto de una función, por lo que es necesario que se invoque a la función en cuestión para que sean definidas.",
            "id": 34
        },
        {
            "referencia": "[2021-2] - Martí Q1P17",
            "pregunta": "Las variables estáticas soportan recursión.",
            "respuesta": "F",
            "explicacion": "Las variables estáticas no soportan recursión porque son de instancia única.",
            "id": 35
        },
        {
            "referencia": "[2021-2] - Martí Q1P18",
            "pregunta": "En ámbitos anidados, la correspondencia entre una referencia a un nombre y su declaración se busca desde el ámbito más cercano al más externo.",
            "respuesta": "V",
            "explicacion": "Es posible sobreescribir la declaración de una variable ya referenciada dentro de un contexto de funciones anidadas. Por lo tanto, el programa empieza a buscar referencias desde el contexto más interno hacia el más externo.",
            "id": 36
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P1",
            "pregunta": "Dada una gramática dada por un eBNF, el árbol sintáctico resultante es único.",
            "respuesta": "F",
            "explicacion": "La particularidad única de un árbol sintáctico no depende de la notación que la describa sino de la ambigüedad de la grámatica y su construcción.",
            "id": 37
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P2",
            "pregunta": "La expresión regular [a-fA-F0-9]+ permite identificar números hexadecimales.",
            "respuesta": "V",
            "explicacion": "La expresión regular permite la combinación de todos los caracteres utilizados en los números hexadecimales.",
            "id": 38
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P3",
            "pregunta": "Los Tokens corresponden solo a palabras claves y reservadas.",
            "respuesta": "F",
            "explicacion": "Los tokens correspondena todo símbolo con un significado especial como lo son las palabras reservadas, literales, operadores, entre otros.",
            "id": 39
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P4",
            "pregunta": "La semántica revisa el significado un programa o sentencia. La semántica puede ser del tipo denotacional o dinámica.",
            "respuesta": "F",
            "explicacion": "Si bien la semántica revisa el significado, no existe el tipo dinámico en su clasificación.",
            "id": 40
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P5",
            "pregunta": "Un ejemplo de análisis sintáctico consiste en revisar si una variable fue previamente declarada antes de usarla.",
            "respuesta": "F",
            "explicacion": "La verificación de la declaración previa de una variable a utilizar es parte del análisis semántico.",
            "id": 41
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P8",
            "pregunta": "La siguiente expresión regular: ```0[a|b](0|1)*``` no puede ser representado en un autómata finito.",
            "respuesta": "F",
            "explicacion": "Las expresiones regulares describen, como su nombre lo indica, a los lenguajes regulares. Por definición, todos los lenguajes regulares pueden ser representados ya sea por un DFA o un NFA.",
            "id": 42
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P9",
            "pregunta": "El árbol sintáctico o Parse Tree es el resultado del analizador sintáctico donde se representa la estructura sintáctica de una cadena de acuerdo a una gramática libre de contexto.",
            "respuesta": "V",
            "explicacion": "El análisis sintáctico es el encargado de verificar si la construcción de la instrucción o sentencia es gramaticalmente correcta. El árbol sintáctico no es más que la representación de la grámatica descrita.",
            "id": 43
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P10",
            "pregunta": "Los lenguajes de alto nivel corresponden a los lenguajes que permiten crear programas manipulando objetos gráficos.",
            "respuesta": "F",
            "explicacion": "Los lenguajes de alto nivel son clasificados a partir de su nivel de abstracción siendo el caso de estos aquellos que son más fáciles de entender por el lado del programdor que por el de la máquina.",
            "id": 44
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P11",
            "pregunta": "Para reconocer los Tokens el analizador semántico utiliza expresiones regulares.",
            "respuesta": "F",
            "explicacion": "El analizador léxico es que el utiliza expresiones regulares para reconocer los tokens.",
            "id": 45
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P13",
            "pregunta": "El analizador sintáctico de un lenguaje es un reconocedor de que un programa está correctamente escrito. ",
            "respuesta": "V",
            "explicacion": "El analizador sintáctico revisa la correctitud del programa con respecto a lo que dice la gramática que lo gobierna.",
            "id": 46
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P1",
            "pregunta": "En un proceso de compilación, la tabla de simbolos ayuda a resolver las ambiguedades en los árboles sintácticos.",
            "respuesta": "F",
            "explicacion": "La ambigüedad de un árbol sintáctico depende únicamente de la ambigüedad de la gramática que lo genera. Una ambigüedad no se puede arreglar desde el proceso de compilación.",
            "id": 47
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P2",
            "pregunta": "Durante la etapa de analisis sintáctico, un error sintáctico se produce porque es posible construir mas de un parse-tree para una misma expresion.",
            "respuesta": "F",
            "explicacion": "Que exista más de un parse-tree para una misma expresión implica que la gramática utilizada es ambigüa, mas no un error de construcción per se.",
            "id": 48
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P3",
            "pregunta": "En ámbitos anidados, la correspondencia entre una referencia a un nombre y su declaración se busca desde el ámbito más cercano al más externo. ",
            "respuesta": "V",
            "explicacion": "Es posible sobreescribir la declaración de una variable ya referenciada dentro de un contexto de funciones anidadas. Por lo tanto, el programa empieza a buscar referencias desde el contexto más interno hacia el más externo.",
            "id": 49
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P4",
            "pregunta": "En la compilación separada, las unidades del programa pueden compilarse en diferentes tiempos, pero se consideran las dependencias entre si. ",
            "respuesta": "V",
            "explicacion": "La compilación separada se basa en la división del código fuente en varios archivos de códigos más pequeños. Es necesario que se considere las dependencias entre archivos para poder aprovechar lo que la modalidad permite.",
            "id": 50
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P5",
            "pregunta": "En BNF se puede describir alternación y en eBNF alternación, agrupación, elementos opcionales y repetición.",
            "respuesta": "V",
            "explicacion": "eBNF es una forma extendida de la notación BNF original. Por lo tanto, esta notación extendida permite describir más tipos de operaciones.",
            "id": 51
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P6",
            "pregunta": "Una gramática ambigüa se produce cuando el ligado de memoria se hace de manera implícita.",
            "respuesta": "F",
            "explicacion": "La gramática es ambigüa netamente por su construcción.",
            "id": 52
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P7",
            "pregunta": "Una expresión regular permite describir patrones de cadenas de caracteres teniendo asociado un arbol sintáctico.",
            "respuesta": "F",
            "explicacion": "Los árboles sintácticos no pueden asociarse a una expresión regular.",
            "id": 53
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P8",
            "pregunta": "La sintaxis de un lenguaje de programación se puede describir usando una gramática libre de contexto.",
            "respuesta": "V",
            "explicacion": "Una manera de describir la sintaxis es mediante la notación BNF la cual se basa en gramáticas libres de contexto.",
            "id": 54
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P9",
            "pregunta": "El orden de las etapas de compilación es: \n```Análisis Léxico -> Análisis Semántico -> Análisis Sintáctico -> Generación de código```",
            "respuesta": "F",
            "explicacion": "El orden común de las etapas de compilación es: Análisis Léxico -> Análisis Sintáctico -> Análisis Semántico -> Generación de código",
            "id": 55
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P10",
            "pregunta": "C es un lenguaje de scripting, de ligado de memoria implicito, y ambito dinamico.",
            "respuesta": "F",
            "explicacion": "C es un lenguaje procedural con ligado de memoria explícito y de ámbito estático.",
            "id": 56
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P1",
            "pregunta": "Una de las principales características de los lenguajes imperativos es que se declara lo que se quiere hacer, no el cómo.",
            "respuesta": "F",
            "explicacion": "Los lenguajes imperativos tienen como fundamento programar pensando en el cómo resolver los problemas, no lo que se pretende lograr.",
            "id": 57
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P2",
            "pregunta": "Dentro de los lenguajes declarativos podemos encontrar a C, C++ y Java (entre otros).",
            "respuesta": "F",
            "explicacion": "C, C++ y Java son ejemplos de lenguajes imperativos.",
            "id": 58
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P3",
            "pregunta": "Los lenguajes funcionales son aquellos que se basan en el cálculo Lambda. ",
            "respuesta": "V",
            "explicacion": "Los lenguajes funcionales nacen bajo el fundamento del cálculo Lambda.",
            "id": 59
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P4",
            "pregunta": "Si bien la semántica implica el significado, esta se puede ver influenciada por la sintaxis.",
            "respuesta": "V",
            "explicacion": "La sintaxis está relacionada con la correcta escritura de una sentencia y, por lo tanto, es lógico que tenga implicancia en su significado posterior.",
            "id": 60
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P5",
            "pregunta": "La sintaxis corresponde al proceso de dotar de un significado no ambigüo a la gramática.",
            "respuesta": "F",
            "explicacion": "El significado no ambigüo de una gramática solo se puede lograr con el correcto diseño de esta.",
            "id": 61
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P6",
            "pregunta": "La Jerarquía de Chomsky ilustra como el aprender nuevos paradigmas nos puede llevar al nivel 3 del programador: poder escribir expresiones regulares.",
            "respuesta": "F",
            "explicacion": "La Jerarquía de Chomsky sirve para clasificar los lenguajes con respecto a su representación por medio de los diversos tipos de autómatas disponibles.",
            "id": 62
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P7",
            "pregunta": "A diferencia C o C++, en Python se interpreta directamente el código fuente durante la ejecución. ",
            "respuesta": "V",
            "explicacion": "Python es un lenguaje interpretado y, por ende, revisa el código directamente en tiempo de ejecución.",
            "id": 63
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P8",
            "pregunta": "Una característica de la gramática libre de contexto es que debe ser representado por un autómata finito.",
            "respuesta": "F",
            "explicacion": "Una gramática de contexto libre no puede ser representada por un autómata finito porque esta no describe lenguajes regulares.",
            "id": 64
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P9",
            "pregunta": "En las gramáticas libres de contexto el simbolo ```ε``` representa una cadena vacía.",
            "respuesta": "V",
            "explicacion": "El símbolo ε se utiliza convencionalmente para representar una cadena vacía.",
            "id": 65
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P10",
            "pregunta": "Lenguajes orientados a objetos, como Java y C, son claros ejemplos de lenguajes imperativos.",
            "respuesta": "F",
            "explicacion": "C es un lenguaje procedural que no permite la OO.",
            "id": 66
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P1",
            "pregunta": "Pascal es un lenguaje imperativo que no permite elementos de la programación orientada a objetos.",
            "respuesta": "V",
            "explicacion": "Pascal es un lenguaje procedural que no permite la OO.",
            "id": 67
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P2",
            "pregunta": "Java y C son lenguajes de programación que interpretan directamente el código fuente durante su ejecución",
            "respuesta": "F",
            "explicacion": "Tanto Java como C necesitan de la compilación para revisar el código fuente.",
            "id": 68
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P3",
            "pregunta": "La tendencia dentro del mundo de los lenguajes de programación es que estos sean multiparadigmas como es el caso de Python.",
            "respuesta": "V",
            "explicacion": "La tendencia de los lenguajes de programación avanzan hacia lenguajes que permitan hacer de todo y tengan un enfoque multiparadigma.",
            "id": 69
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P4",
            "pregunta": "Las expresiones regulares son una técnica para especificar y reconocer tokens importante al momento de efectuar el analisis semántico en el código.",
            "respuesta": "F",
            "explicacion": "Las expresiones regulares se utilizan en el análisis léxico.",
            "id": 70
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P5",
            "pregunta": "La notacion BNF es un metalenguaje que permite especificar formalmente gramáticas libres de contexto.",
            "respuesta": "V",
            "explicacion": "La notación Backus-Naur Form está hecha para describir gramáticas de contexto libre.",
            "id": 71
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P6",
            "pregunta": "Las variables dinámicas de stack soportan recursión.",
            "respuesta": "V",
            "explicacion": "Las variables dinámicas de stack pueden ser instancias más de una vez, por lo que soportan recursión.",
            "id": 72
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P7",
            "pregunta": "Las variables dinámicas del stack son ligadas a memoria en el momento que la ejecución alcanza el código ligado a la declaración.",
            "respuesta": "V",
            "explicacion": "Las variables dinámicas del stack son las presentes dentro del contexto de cualquier función. Es necesario que el código de la función sea ejecutado para que estas puedan ser declaradas en la memoria.",
            "id": 73
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P8",
            "pregunta": "La memoria del heap permite mantener objetos que se asignan y liberan automáticamente al activar o desactivar, respectivamente, un ambiente de ejecución.",
            "respuesta": "F",
            "explicacion": "Hay lenguajes como C que necesitan de una liberación manual de memoria.",
            "id": 74
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P9",
            "pregunta": "En C++, una definición especifica el nombre de la variable, liga tipo, y asigna memoria.",
            "respuesta": "V",
            "explicacion": "Dado que C++ posee una ámbito estático, una definición correcta necesita conocer el nombre, tipo y espacio en memoria que ocupara la nueva variable a crear durante el tiempo de compilación.",
            "id": 75
        },
        {
            "referencia": "[2024-2] - José Luis Martí. Q1P10",
            "pregunta": "En cuanto al tiempo de ligado, este será dinámico cuando sucede en cualquier momento posterior al proceso de compilación.",
            "respuesta": "F",
            "explicacion": "El ligado dinámico solo sucede durante el tiempo de ejecución del programa.",
            "id": 76
        },
        {
            "referencia": "[2021-x]  José Luis Martí C1P1",
            "pregunta": "C es un lenguaje imperativo que permite elementos de la programación orientada al objeto.",
            "respuesta": "F",
            "explicacion": "C es un lenguaje procedural que no soporta OO.",
            "id": 77
        },
        {
            "referencia": "[2021-x]  José Luis Martí C1P2",
            "pregunta": "Java es un lenguaje orientado al objeto con ciertos elementos propios de un lenguaje imperativo.",
            "respuesta": "V",
            "explicacion": "Java es un lenguaje OO que posee características de los lenguajes imperativos.",
            "id": 78
        },
        {
            "referencia": "[2021-x]  José Luis Martí C1P3",
            "pregunta": "Scheme es un lenguaje funcional que incorpora elementos de programación imperativa.",
            "respuesta": "V",
            "explicacion": "Aunque es un lenguaje basado en el esquema funcional, Scheme incorpora elementos imperativos como el control de flujo y asignación de variables.",
            "id": 79
        },
        {
            "referencia": "[2021-x]  José Luis Martí C1P4",
            "pregunta": "Python es un lenguaje scripting que no permite la orientacion a objetos.",
            "respuesta": "F",
            "explicacion": "Python es un lenguaje de scripting que soporta OO.",
            "id": 80
        }
    ],
    "alt": [
        {
            "pregunta": "¿Cuál de las siguientes definiciones respecto a la sintaxis son correctas?\n I. Sintaxis léxica: Define reglas para los tokens (tales como identificadores, literales, operadores...).\n II. Sintaxis concreta: Refiere a una representación de un programa según símbolos del alfabeto.\n III. Sintaxis abstracta: Solo lleva la información esencial del programa. Útil para usar previo a la generación del código.\na. Solo II.\nb. Solo I y II.\nc. Solo II y III.\nd. Todas las anteriores.",
            "respuesta": "b",
            "explicacion": "La sintaxis abstracta es utilizada para la generación de código, no en una etapa previa a este.",
            "referencia": "Original",
            "id": 1020,
            "intAnswers": 4
        },
        {
            "pregunta": "Con respecto a los tipos de la semántica, se puede decir que...\n I. La semántica estática define restricciones respecto a qué textos son válidos para la sintaxis.\n II. Ejemplos de semántica estática son: Verificar que Switch tenga rótulos diferentes o que una variable sea identificada antes de usarla.\n III. La semántica dinámica define el comportamiento de los constructos del lenguaje.\n IV. La semántica dinámica ha de ser especificada de manera informal para mayor libertad del código.\na. Solo I y II.\nb. Solo II y III.\nc. Solo III y IV.\nd. Solo I, II y III.\ne. Todas las anteriores.",
            "respuesta": "d",
            "explicacion": "Tecnicamente la d no es incorrecta pues se puede definir informalmente, sin embargo, no es necesario hacerlo asi, de hecho se recomienda lo contrario.",
            "referencia": "Original",
            "id": 1021,
            "intAnswers": 5
        },
        {
            "pregunta": "Con respecto a la semántica dinámica, los siguientes metodos de especificacion...\n    I. Semantica Operacional: Significado ha de ser establecido especificando los efectos de una ejecucion\n    II. Semantica Denotacional: Significado se denota mediante sentencias explicitas que denotan el efecto de la computacion\n    III. Semantica Axiomatica: Especifica propiedades de los efectos de afirmaciones logicas.\n    \nCuales son verdad?\na. Solo II\nb. Solo III\nc. Solo I y II\nd. Solo I y III\ne. Solo II y III",
            "respuesta": "d",
            "explicacion": "La II no se denota mediante sentencias explicitas, si no mediante objetos matematicos",
            "referencia": "Original",
            "id": 1022,
            "intAnswers": 5
        },
        {
            "pregunta": "Cual de las siguientes alternativas corresponde al orden correcto del proceso de compilacion?\na. Programa fuente -> Analisis Sintactico -> Analisis Semantico -> Analisis Lexico -> Generacion del codigo -> Programa\nb. Programa fuente -> Analisis Semantico  -> Analisis Sintactico -> Analisis Lexico -> Generacion del codigo -> Programa\nc. Programa fuente -> Analisis Lexico -> Analisis Sintactico -> Analisis Semantico -> Generacion del codigo -> Programa\nd. Ninguna de las anteriores esta correcta, puesto que no existe el analisis semantico",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1023,
            "intAnswers": 4
        },
        {
            "pregunta": "Con respecto a la jerarquia de Chomsky: Cual es el orden correcto de los lenguajes considerando de menor a mayor su tipo?\na. Recursivamente Enumerables -> Sensibles al contextos -> Lenguajes regulares -> Independientes del contextos\nb. Recursivamente Enumerables -> Sensibles al contexto -> Independientes de Contexto -> Lenguajes regulares\nc. Sensibles al contexto -> Recursivamente enumerables -> Lenguajes regulares -> Independientes del contextos\nd. Sensibles al contexto -> Recursivamente enumerables -> Independientes de Contexto -> Lenguajes regulares",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1024,
            "intAnswers": 4
        },
        {
            "pregunta": "Considere la siguiente gramatica libre de contexto:    \n```\nA -> X|Y\naX -> aX|Z\nY -> A|X|bb\n```\nCuales es el problema de esta gramatica?\na. Esta mal escrita puesto que posee un simbolo terminal en la parte de no terminales\nb. No esta definido la 4-tupla, por lo que no puede ser definida correctamente\nc. No tiene simbolo de partida S, el cual si o si debe ser este simbolo\n d.Esta mala porque usar gramaticas libres de contexto esta mal en general",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1025,
            "intAnswers": 4
        },
        {
            "pregunta": "Caracteristicas de la Backus-Naur Form (BNF) son...\n \tI. Lado izquierdo es un simbolo terminal, mientras derecho corresponde a un no terminal\n   II. La expresion \"|\" indica alternar entre opciones\n    III. La ultima regla corresponde siempre a la que terminara la expresion\n    IV. Los parentesis permiten agrupar elementos\n    \na. Solo II\nb. Solo I y II\nc. Solo II y IV\nd. Solo II, III y IV",
            "respuesta": "a",
            "explicacion": " I: Derecho puede ser o no un terminal.\nIII. No necesariamente IV.\nCorresponde a EBNF, no BNF.",
            "referencia": "Original",
            "id": 1026,
            "intAnswers": 4
        },
        {
            "pregunta": "Caracteristicas de la extended Backus-Naur Form (eBNF) son...\n    I. Lado izquierdo es un simbolo no terminal, mientras derecho corresponde a un terminal\n    II. Elementos opcionales son aquellos que se encuentran dentro parentesis cuadrados []\n    III. La llave {x} indica que la palabra a repetirse x veces, con x entre 1 o mas\n    IV. Los parentesis permiten agrupar elementos.\nSolo I y II\nb. Solo I y IV\nc. Solo II y IV\nd. Solo I, II y IV",
            "respuesta": "c",
            "explicacion": " I. Derecho no necesariamente a de ser terminal. III. La llave puede ser 0",
            "referencia": "Original",
            "id": 1027,
            "intAnswers": 4
        },
        {
            "pregunta": "Cuales de los siguientes no son definidos como tipos de tokens?\n    I. Palabras claves reservadas\n    II. Literales y constantes\n    III. Identificadores\n    IV. Simbolos de Operadores\n    V. Comentarios\na. Solo II\nb. Solo III\nc. Solo IV\nd. Solo II y IV\ne. Ninguno esta mal definido\nf. Todos estan mal definidos\n",
            "respuesta": "e",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1028,
            "intAnswers": 6
        },
        {
            "referencia": "[2021-2] Mart\u00c3\u00ad Q1P7 ",
            "pregunta": "A partir de las siguientes reglas de precedencia para operadores:\n```\nMayor Precedencia   *, /, not\n                    +, &, mod\n                    -, -\n                     =, /=, <, <=, >=, >\n                    and\nMenor Precedencia   or, xor\n```\nY considerando asociatividad de izquierda a derecha, \u00c2\u00bfcu\u00c3\u00a1l es el orden correcto de evaluaci\u00c3\u00b3n de la expresi\u00c3\u00b3n: a * b - 1 + c?\nSeleccione una:\na. (a * b) -> (1 + c) -> ((a * b) - (1 + c))\nb.(b - 1) -> (a * (b - 1)) -> ((a * (b - 1) + c) \nc. (a * b) -> ((a * b) - 1 -> (((a * b) - 1) + c\nd. (1 + c) -> (b - (1 + c)) -> (( a * (b - ( 1 + c)))",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1029,
            "intAnswers": 4
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P12",
            "pregunta": "Tomar en cuenta el siguiente programa, escrito en sintaxis tipo Javascript:\n```js\nvar x, y, z;\nfunction sub1() {\n     var a, y, z;\n     ...\n    }\nfunction sub2() {\n     var a, b, z;\n     ...\n    }\nfunction sub3() {\n     var a, x, w;\n     ...\n    }\n```\nDada la siguiente secuencia de llamadas en un \u00c3\u00a1mbito din\u00c3\u00a1mico: main --> sub1() --> sub3() --> sub2(), \u00c2\u00bfcu\u00c3\u00a1les\nson todas las variables visibles durante la ejecuci\u00c3\u00b3n de sub2()?\n\na. a local, b local, x de main, y de `sub1()`, z local\nb. a local, b local, x de main, y de main, z local\nc. a local, b local, z local\nd. a local, b local, w de `sub3()`, x de `sub3()`, y de `sub1()`, z local",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1030,
            "intAnswers": 4
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P14 - PREGUNTA ADAPTADA",
            "pregunta": "\nDada la siguiente BNF:\n```\n    Sentencia :: = ( [Operador] Sentencia [Expresion] ) | Constante | Reservada\n    Expresion :: = Sentencia |     Operador :: = + | *\n    Constante :: = 0 | 1 | 2 | 3 | 4 | 5\n    Reservada :: = if | else | while\n```\nCuales de las siguientes expresiones no son v\u00c3\u00a1lidas para esta gram\u00c3\u00a1tica?\nI. ( + 4 5)  II)  (* (0 1 +)) \nIII. (else if)\nIV. (* if (4 + else))  \na. Solo I\nb. Solo II\nc. Solo III\nd. Solo IV\nd. I, II y III\ne. II, III y IV\n",
            "respuesta": "e",
            "explicacion": "No explicacion entregada",
            "id": 1031,
            "intAnswers": 5
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P6",
            "pregunta": "Dado el siguiente EBNF \n```\n    <inicio> ::= <variable> = <expresion>\n    <variable> ::= x|y|z\n    <expresion> ::= <expresion> @ <termino> | <termino>\n    <termino> ::= <termino> # <expresion> | <variable>\n```\n¿Cual de las siguientes expresiones no es válida para la gramática?\na. Todas son válidas\nb. x = x@y#z \nc. z = x@y@z#z\nd. y = y#z@x",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1032,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Rodrigo S.  Q1P12",
            "pregunta": "La siguiente BNF genera árboles sint\u00c3\u00a1cticos ambiguos:\n```\n    <inicio> ::= <variable> = <expresion>\n    <variable> ::= x|y|z\n    <expresion> ::= <expresion> @ <termino> | <termino>\n    <termino> ::= <termino> # <expresion> | <variable>\n```\nSeleccione la respuesta correcta:\na. Falso, el # tiene mayor precedencia que el @\nb. Verdadero\nc. Falso, el @ tiene mayor precedencia que el # \n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1033,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Rodrigo S.  Q1P14",
            "pregunta": "\nLa secuencia principal de compilaci\u00c3\u00b3n de un programa es la siguiente:\n\na. Programa fuente, Generador de c\u00c3\u00b3digo intermedio, analizador l\u00c3\u00a9xico, analizador sint\u00c3\u00a1ctico, Generador de C\u00c3\u00b3digo, Lenguaje de M\u00c3\u00a1quina.\nb. Programa fuente, analizados sem\u00c3\u00a1ntico, analizador sint\u00c3\u00a1ctico, Generador de c\u00c3\u00b3digo y analizador l\u00c3\u00a9xico, Lenguaje de M\u00c3\u00a1quina.\nc. Programa fuente, analizados l\u00c3\u00a9xico, analizador sint\u00c3\u00a1ctico, Generador de c\u00c3\u00b3digo intermedio y analizador sem\u00c3\u00a1ntico, Generador de C\u00c3\u00b3digo, Lenguaje de M\u00c3\u00a1quina.\nd. Programa fuente, analizados l\u00c3\u00a9xico, analizador sem\u00c3\u00a1ntico, Generador de c\u00c3\u00b3digo intermedio y analizador sint\u00c3\u00a1ctico, Generador de C\u00c3\u00b3digo, Lenguaje de M\u00c3\u00a1quina.\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1034,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Rodrigo S.  Q1P15",
            "pregunta": "\nLos lenguajes de programaci\u00c3\u00b3n pueden ser categorizado acorde a uno de los siguientes paradigmas:\n\na. Puede ser s\u00c3\u00b3lo Imperativo o Funcional\nb. Puede ser s\u00c3\u00b3lo Imperativo, o funcional, o declarativo, u orientado a objetos. \nc. Puede incorporar m\u00c3\u00baltiples paradigmas\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1035,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Wladimir O.  Q1P1",
            "pregunta": "\nConsidere una gr\u00c3\u00a1m\u00c3\u00a1tica libre de contexto definida en base a los siguientes elementos:\n\nV: X,Y,Z\n\u00ce\u00a3: a,b,c\nS: X\n        X  \u00e2\u2020\u2019 Y|Z\n        aX \u00e2\u2020\u2019 Z\n        Z  \u00e2\u2020\u2019 \u00cf\u00b5\n        Y  \u00e2\u2020\u2019 aX|bZ|cZ\n\nIndique la alternativa correcta:\n\na. Estamos en presencia de eBNF en realidad. \nb. Las reglas de producci\u00c3\u00b3n indicadas en  son m\u00c3\u00a1s bien expresiones regulares. \nc. No es en realidad una gr\u00c3\u00a1matica libre de contexto. \nd.  es el conjunto de s\u00c3\u00admbolos no terminales. \ne. Ninguna de las alternativas es correcta.\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1036,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Wladimir O.  Q1P2",
            "pregunta": "\nEn base al siguiente fragmento de c\u00c3\u00b3digo escrito en C++:\n\n    extern int x; \n    int y; \n    int z = 0; \n\nIndique la alternativa correcta:\n\na. \"x\", \"y\" y \"z\" est\u00c3\u00a1n declaradas, pero solo \"z\" esta definida. \nb. \"x\", \"y\" y \"z\" est\u00c3\u00a1n definidas, pero solo \"z\" esta declarada. \nc. \"x\" y \"y\" est\u00c3\u00a1n declaradas, y solo \"z\" esta definida. \nd. \"x\", \"y\" y \"z\" est\u00c3\u00a1n declaradas, pero solo \"y\" y \"z\" estan definidas. \ne. Ninguna de las alternativas es correcta.\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1037,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Wladimir O.  Q1P3",
            "pregunta": "\nEn base al siguiente fragmento de c\u00c3\u00b3digo escrito en C++:\n\n    void funcion1(){ \n    static double x = 0; \n    x = x + 1; \n    cout <<\"x: \"<< x <<endl; \n    }; \n\nLa \"x\" variable  es de tipo:\n\na. Din\u00c3\u00a1mica de stack, y solo visible dentro de la funci\u00c3\u00b3n. \nb. Din\u00c3\u00a1mica de stack, y visible desde fuera de la funci\u00c3\u00b3n. \nc. Din\u00c3\u00a1mica de heap, y visible desde fuera de la funci\u00c3\u00b3n. \nd. Est\u00c3\u00a1tica, y visible desde fuera de la funci\u00c3\u00b3n. \ne. Est\u00c3\u00a1tica, y solo visible dentro de la funci\u00c3\u00b3n.\n",
            "respuesta": "e",
            "explicacion": "No explicacion entregada",
            "id": 1038,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Wladimir O.  Q1P5",
            "pregunta": "\nSobre las variables est\u00c3\u00a1ticas, es incorrecto afirmar que: \n\na. Son escencialmente \u00c3\u00batiles para implementar recursi\u00c3\u00b3n. \nb. Su memoria no se reasigna durante todo el tiempo de ejecuci\u00c3\u00b3n. \nc. Se pueden utilizar en diferentes \u00c3\u00a1mbitos. \nd. En C++ se indican utilizando static. \ne. Todas las afirmaciones son correctas.\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1039,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P11",
            "pregunta": "\nCual de los siguientes no corresponde a un paradigma de la programacion?\na. Imperativo\nb. Estatico\nc. Orientado a objeto\nd. Logico\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1040,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P12",
            "pregunta": "\nCual de los conceptos siguientes no esta definido como corresponde?\na. Semantica: Estudio del significado de los signos linguistiscos y de sus combinaciones\nb. Lenguaje (formal): Conjunto de reglas que definen las secuencias correctas de los elementos de un lenguaje de programacion\nc. Alfabeto: Conjunto de simbolos, letras o tokens con el cual se puede formar la cadena de un lenguaje.\nd. Gramatica (formal): Estructura matematica con un conjunto de reglas de formacion que definen las cadenas de caracteres admisibles en un determinado lenguaje formal\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1041,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P13",
            "pregunta": "\nCual de los siguientes casos no se hace uso de la memoria estatica?\na. Variable definida con el modificador sintactico\nb. Variable local compartida\nc. Parametro\nd. Variable global\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1042,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P14",
            "pregunta": "A partir de las siguientes reglas de precedencia para operadores:\n\nMayor Precedencia   , /, not\n                    +, -, -                    -, -                     =, /=, <, <=, >=, >\n                    and\nMenor Precedencia   or, xor\n\nY considerando asociatividad de derecha a izquierda, \u00c2\u00bfcu\u00c3\u00a1l es el orden correcto de evaluaci\u00c3\u00b3n de la expresi\u00c3\u00b3n: a b \u00e2\u20ac\u201c 1 + c?\nSeleccione una:\na. ((a * b ){1} \u00e2\u20ac\u201c (1 + c){2} ){3}\nb. (((a * (b-1) {1} ) {2} ) + c){3}\nc. d. (((a * b){1} - 1){2} + c){3}\n\nLos numeros con {} son el orden en la cual  se evalua la expresion que tiene a la izquierda en parentsis\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1043,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P15",
            "pregunta": "\n\nConsidere la siguiente funcion en C, es cierto que...\n\n    char f    {\n        static int b = 0;\n        int c = strlen(a);\n        char d = malloc(c - b++);\n\n        return d ? strcpy(d, a+b) : NULL;\n    }\n\na. c es una variable de stack y a una de heap\nb. b es una variable estatica y d una de heap\nc. c es una variable de heap y a una de heap\nd. c es una variable de stack yd una de heap\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1044,
            "intAnswers": 4
        },
        {
            "pregunta": "\n([2021-x]  Jose Luis Marti C1P21) \nCual de los siguientes lenguajes no es fuertemente tipado?\na. Pascal\nb. Java\nc. Prolog\nd. Python\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1045,
            "intAnswers": 4
        },
        {
            "pregunta": "\n([2021-x]  Jose Luis Marti C1P22) \nCual de los siguientes lenguajes usa comprobacion de tipos estatica?\na. C\nb. Scheme\nc. Perl\nd. Python\n\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1046,
            "intAnswers": 4
        },
        {
            "referencia": "enfoque impaciente",
            "pregunta": "\n([2021]  Jose Luis Marti C1P23) \nQue mecanismo de recoleccion de basura se debe implantar en un lenguaje de programacion donde todo el ligado de memoria es estatico o dinamico de stack?\na. Basado en contadores de referencias b. Basado en marcas y barrido c. Una combinacion de ambos, un esquema para la memoria estatica y el otro para el stack\nd. Ninguna de las anteriores\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1047,
            "intAnswers": 4
        }
    ]
}
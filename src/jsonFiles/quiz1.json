{
    "vf": [
        {
            "pregunta": "En paradigmas de la programacion, imperativo es aquel de ejecucion secuencial, tales como procedural o Orientado a objetos ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1
        },
        {
            "pregunta": "En paradigmas de la programacion, imperativo es aquel que se define como se quiere hacer o no, tales como procedural o Orientado a objetos ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 2
        },
        {
            "pregunta": "En paradigmas de la programacion, declarativo es aquel que se define como se quiere hacer o no, como el funcional o Logico ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 3
        },
        {
            "pregunta": "En paradigmas de la programacion, declarativo es aquel de ejecucion secuencial, como el funcional o Logico ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 4
        },
        {
            "pregunta": "Ejemplos de lenguajes procedural son Fortran, Algol, Pascal y C ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 5
        },
        {
            "pregunta": "Ejemplos de lenguajes procedural son Fortran, Algol, Pascal y C++ ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 6
        },
        {
            "pregunta": "Ejemplos de lenguaje orientado a Objeto son SmallTalk, C++ y Java ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 7
        },
        {
            "pregunta": "Ejemplos de lenguaje orientado a Objeto son Algol, C++ y Java ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 8
        },
        {
            "pregunta": "Ejemplos de lenguaje funcional son LISP, Scheme, Haskell ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 9
        },
        {
            "pregunta": "Ejemplos de lenguaje funcional son LISP, Scheme, Prolog ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 10
        },
        {
            "pregunta": "Ejemplos de lenguaje logico son Prolog, LISP ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 11
        },
        {
            "pregunta": "La sintaxis de un lenguaje de programacion es la descripcion precisa de todos los programas gramaticalmente correctos ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 12
        },
        {
            "pregunta": "La sintaxis de un lenguaje de programacion puede ser definido mediante BNF ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 13
        },
        {
            "pregunta": "La sintaxis de un lenguaje de programacion puede ser definido mediante expresiones regulares, mas no BNF ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 14
        },
        {
            "pregunta": "La sintaxis de un lenguaje establece estructura, mas no su significado ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 15
        },
        {
            "pregunta": "La sintaxis de un lenguaje establece su significado, mas no su estructura ",
            "respuesta": "F",
            "explicacion": " Al revez",
            "referencia": "Original",
            "id": 16
        },
        {
            "pregunta": "La semantica de un lenguaje habla respecto al significado del lenguaje, a diferencia de la forma que es especificada por la sintaxis ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 17
        },
        {
            "pregunta": "La semantica de un lenguaje habla respecto a la forma del lenguaje, a diferencia del significado que es especificado por la sintaxis ",
            "respuesta": "F",
            "explicacion": " Las referencias estan al revez",
            "referencia": "Original",
            "id": 18
        },
        {
            "pregunta": "La Backus-Naur Form (BNF) es un metalenguaje creado para especificar gramaticas libre de contexto ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 19
        },
        {
            "pregunta": "La Backus-Naur Form (BNF) es un metalenguaje creado para especificar lenguajes regulares ",
            "respuesta": "F",
            "explicacion": " Es para gramaticas libre de contexto",
            "referencia": "Original",
            "id": 20
        },
        {
            "pregunta": "Las expresiones regulares permiten describir patrones de cadenas de caracteres, utiles para reconocer tokens ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 21
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P1",
            "pregunta": "Un \u00c3\u00a1mbito est\u00c3\u00a1tico es determinado analizando c\u00c3\u00b3digo fuente. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 22
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P2",
            "pregunta": "Prolog es un lenguaje funcional, que incorpora elementos de programaci\u00c3\u00b3n imperativa. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 23
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P3",
            "pregunta": "Uno de los tipos de \u00c3\u00a1mbitos para subprogramas es permitir el anidamiento de \u00c3\u00a9stos, definiendo una ascendencia de tipo din\u00c3\u00a1mico en tiempo de ejecuci\u00c3\u00b3n. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 24
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P4",
            "pregunta": "Una definici\u00c3\u00b3n especifica el nombre de la variable y liga tipo, entre otros atributos, pero no asigna memoria. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 25
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P5",
            "pregunta": "Las variables din\u00c3\u00a1micas de heap pueden ser manipuladas en forma impl\u00c3\u00adcita o expl\u00c3\u00adcita, dependiendo del lenguaje. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 26
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P6",
            "pregunta": "C es un lenguaje imperativo, que permite elementos de la programaci\u00c3\u00b3n l\u00c3\u00b3gica. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 27
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P8",
            "pregunta": "Un \u00c3\u00a1mbito global define una estructura del programa como una secuencia de definiciones de funciones, donde las variables pueden aparecer definidas fuera de ellas. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 28
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P9",
            "pregunta": "El proceso de compilaci\u00c3\u00b3n sigue las siguientes etapas: An\u00c3\u00a1lisis L\u00c3\u00a9xico --> An\u00c3\u00a1lisis Sem\u00c3\u00a1ntico --> An\u00c3\u00a1lisis Sint\u00c3\u00a1ctico --> Generaci\u00c3\u00b3n de C\u00c3\u00b3digo ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 29
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P10",
            "pregunta": "Python es un lenguaje scripting, que permite la orientaci\u00c3\u00b3n a objetos. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 30
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P11",
            "pregunta": "En la modalidad de compilaci\u00c3\u00b3n separada, las unidades de programas pueden compilarse en diferentes tiempos, pero considerando las dependencias entre ellas. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 31
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P13",
            "pregunta": "La memoria del heap permite mantener objetos que se asignan y liberar autom\u00c3\u00a1ticamente al activar o desactivar un ambiente de ejecuci\u00c3\u00b3n. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 32
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P15",
            "pregunta": "Java y C# son lenguajes de programaci\u00c3\u00b3n que usan una m\u00c3\u00a1quina virtual para interpretar directamente el c\u00c3\u00b3digo fuente durante su ejecuci\u00c3\u00b3n. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 33
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P16",
            "pregunta": "Las variables din\u00c3\u00a1micas de stack son ligadas a memoria en el momento que la ejecuci\u00c3\u00b3n alcanza el c\u00c3\u00b3digo ligado a la declaraci\u00c3\u00b3n. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 34
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P17",
            "pregunta": "Las variables est\u00c3\u00a1ticas soportan recursi\u00c3\u00b3n. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 35
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P18",
            "pregunta": "En \u00c3\u00a1mbitos anidados, la correspondencia entre una referencia a un nombre y su declaraci\u00c3\u00b3n se busca desde el \u00c3\u00a1mbito m\u00c3\u00a1s cercano al m\u00c3\u00a1s externo. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 36
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P1",
            "pregunta": "Dada una gram\u00c3\u00a1tica dada por un EBNF, el \u00c3\u00a1rbol sint\u00c3\u00a1ctico resultante es \u00c3\u00banico. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 37
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P2",
            "pregunta": "La expresi\u00c3\u00b3n regular [a-fA-F0-9]+ permite identificar n\u00c3\u00bameros hexadecimales. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 38
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P3",
            "pregunta": "Los Tokens corresponden solo a palabras claves y reservadas. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 39
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P4",
            "pregunta": "La sem\u00c3\u00a1ntica revisa el significado un programa o sentencia. La sem\u00c3\u00a1ntica puede ser del tipo denotacional o din\u00c3\u00a1mica. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 40
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P5",
            "pregunta": "Un ejemplo de an\u00c3\u00a1lisis sint\u00c3\u00a1ctico consiste en revisar si una variable fue previamente declarada antes de usarla. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 41
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P8",
            "pregunta": "La siguiente expresi\u00c3\u00b3n regular 0[a|b](0|1)* no puede ser representado en un aut\u00c3\u00b3mata finito. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 42
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P9",
            "pregunta": "El \u00c3\u00a1rbol sint\u00c3\u00a1ctico o Parse Tree es el resultado del analizador sint\u00c3\u00a1ctico donde se representa la estructura sint\u00c3\u00a1ctica de una cadena de acuerdo a una gram\u00c3\u00a1tica libre de contexto ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 43
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P10",
            "pregunta": "Los lenguajes de alto nivel corresponden a los lenguajes que permiten crear programas manipulando objetos gr\u00c3\u00a1ficos. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 44
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P11",
            "pregunta": "Para reconocer los Tokens el analizador sem\u00c3\u00a1ntico utiliza expresiones regulares. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 45
        },
        {
            "referencia": "[2022-1] - Rodrigo S. Q1P13",
            "pregunta": "El analizador sint\u00c3\u00a1ctico de un lenguaje es un reconocedor de que un programa est\u00c3\u00a9 correctamente escrito. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 46
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P1",
            "pregunta": "En un proceso de compilacion, la tabla de simbolos ayuda a resolver las ambiguedades en los arboles sintacticos. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 47
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P2",
            "pregunta": "Durante la etapa de analisis sintactico, un error sintactico se produce porque es posible construir mas de un parse-tree para una misma expresion. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 48
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P3",
            "pregunta": "En ambitos anidados, la correspondencia entre una referencia a un nombre y su declaracion se busca desde el ambito mas cercano al mas externo. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 49
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P4",
            "pregunta": "En la compilacion separada, las unidades del programa pueden compilarse en diferentes tiempos, pero se consideran las dependencias entre si. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 50
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P5",
            "pregunta": "En BNF se puede describir alteraciony en EBNF alternacion, agrupacion, elementos opcionales y repeticion. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 51
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P6",
            "pregunta": "Una gram\u00c3\u00a1tica ambigua se produce cuando el ligado de memoria se hace de manera implicita. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 52
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P7",
            "pregunta": "Una expresion regular permite describir patrones de cadenas de caracteres teniendo asociado un arbol sintactico. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 53
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P8",
            "pregunta": "La sintaxis de un lenguaje de programacion se puede describir usando una gramatica libre de contexto. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 54
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P9",
            "pregunta": "El orden de las etapas de compilacion es: An\u00c3\u00a1lisis Lexico -> Analisis Semanticos -> Anilisis Sintactico -> Generacion de cosdigo. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 55
        },
        {
            "referencia": "[2022-1] - Jorge D. Q1P10",
            "pregunta": "C es un lenguaje de scripting, de ligado de memoria implicito, y ambito dinamico. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 56
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P1",
            "pregunta": "Una de las pricipales caracter\u00c3\u00adsticas de los lenguajes imperativos es que se declara lo qu\u00c3\u00a9 se quiere hacer, no el c\u00c3\u00b3mo. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 57
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P2",
            "pregunta": "Dentro de los lenguajes declarativos podemos encontrar a C, C++ y Java (entre otros). ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 58
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P3",
            "pregunta": "Los lenguajes funcionales son aquellos que se basan en el c\u00c3\u00a1lculo Lambda. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 59
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P4",
            "pregunta": "Si bien la sem\u00c3\u00a1ntica implica el significado, esta se puede ver influenciada por la sintaxis. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 60
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P5",
            "pregunta": "La sintaxis corresponde al proceso de dotar de un significado no ambiguo a la gram\u00c3\u00a1tica. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 61
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P6",
            "pregunta": "La Jerarqu\u00c3\u00ada de Chomsky ilustra como el aprender nuevos paradigmas nos puede llevar al nivel 3 del programador: poder escribir expresiones regulares. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 62
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P7",
            "pregunta": "A diferencia C o C++, en Python se interpreta directamente el c\u00c3\u00b3digo fuente durante la ejecuci\u00c3\u00b3n. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 63
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P8",
            "pregunta": "Una caracter\u00c3\u00adstica de la gram\u00c3\u00a1tica libre de contexto es que debe ser representado por un automata finito. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 64
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P9",
            "pregunta": "En las gram\u00c3\u00a1ticas libres de contexto el simbolo  representa representa una cadena vac\u00c3\u00ada. ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 65
        },
        {
            "referencia": "[2024-2] - Wladimir O. Q1P10",
            "pregunta": "Lenguajes orientados a objeto, como Java y C, son claros ejemplos de lenguajes imperativos. ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 66
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P1",
            "pregunta": "Pascal es un lenguaje imperativo, que no permite elementos de la programacion orientada a objeto ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 67
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P2",
            "pregunta": "Java y C son lenguajes de programacion que interpretan directamente el codigo fuente durante su ejecucion ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 68
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P3",
            "pregunta": "La tendencia dentro del mundo de los lenguajes de programacion es que estos sean multiparadigmas, como es el caso de Python ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 69
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P4",
            "pregunta": "Las expresiones regulares son una tecnica para especificar y reconocer tokens, importantes al momento de analisis semantico del codigo ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 70
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P5",
            "pregunta": "La notacion BNF es un metalenguaje que permite especificar formalmente gramaticas libres de contexto ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 71
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P6",
            "pregunta": "Las variables dinamicas de stackk soportan recursion ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 72
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P7",
            "pregunta": "Las variables dinamicas del stack son ligadas a memoria en el momento que la ejecucion alcanza el codigo ligado a la declaracion ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 73
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P8",
            "pregunta": "La memoria del heap permite mantener objetos que se asignan y liberan automaticamente al activar o desactivar, respectivametne, un ambiente de ejecucion ",
            "respuesta": "F",
            "explicacion": " No automatico",
            "id": 74
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P9",
            "pregunta": "En C++, una definicion especifica el nombre de la variable, liga tipo, y asigna memoria ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 75
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P10",
            "pregunta": "En cuanto al tiempo de ligado, este sera dinamico cuando sucede en cualquier momento posterior al proceso de compilacion ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 76
        },
        {
            "referencia": "[2021-x]  Jose Luis Marti C1P1",
            "pregunta": "C es un lenguaje imperativo, que permite elementros de la programacion orientada al objeto ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 77
        },
        {
            "referencia": "[2021-x]  Jose Luis Marti C1P2",
            "pregunta": "Java es un lenguaje orientado al objeto, con ciertos elementos propios de un lenguaje imperativo ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 78
        },
        {
            "referencia": "[2021-x]  Jose Luis Marti C1P3",
            "pregunta": "Scheme es un lenguaje funcional, que incorpora elementos de programacion imperativa ",
            "respuesta": "V",
            "explicacion": "No explicacion entregada",
            "id": 79
        },
        {
            "referencia": "[2021-x]  Jose Luis Marti C1P4",
            "pregunta": "Python es un lenguaje scripting, que no permite la orientacion a objetos ",
            "respuesta": "F",
            "explicacion": "No explicacion entregada",
            "id": 80
        }
    ],
    "alt": [
        {
            "pregunta": "\nCual de las siguientes definiciones respecto a la sintaxis son correctas?\n    I. Sintaxis lexica: Define reglas para los tokens (tales como identificadores, literales, operadores...)\n    II. Sintaxis concreta: Refiere a una representacion de un programa segun simbolos del alfabeto\n    III. Sintaxis abstracta: Solo lleva la informacion escencial del programa, util para usar previo a la generacion del codigo\na. Solo II\nb. Solo I y II\nc. Solo II y III\nd. Todas las anteriores\n\n",
            "respuestas": [
                "a"
            ],
            "respuesta": "b",
            "explicacion": " La III es falsa por que se utiliza para la generacion del codigo, no previa a esta",
            "referencia": "Original",
            "id": 1020,
            "intAnswers": 4
        },
        {
            "pregunta": "\n\nCon respecto a los tipos de la semantica, se puede decir...\n    I. La semantica estatica define restricciones sobre respecto a que textos son validos para la sintaxis\n    II. Ejemplos de semantica estatica son : Verificar que switch tenga rotulos diferentes, o que una variable sea identificada antes de usarla\n    III. La semantica dinamica define el comportamiento de los constructos del lenguaje\n    IV. La semantica dinamica ha de ser especificada de manera informal para mayor libertad del codigo\na. Solo I y II\nb. Solo II y III\nc. Solo III y IV\nd. Solo I, II y III\ne. Todas las anteriores\n\n",
            "respuesta": "d",
            "explicacion": " Tecnicamente la d no es incorrecta pues se puede definir informalmente, sin embargo, no es necesario hacerlo asi, de hecho se recomienda lo contrario.",
            "referencia": "Original",
            "id": 1021,
            "intAnswers": 5
        },
        {
            "pregunta": "\n\nCon respecto a la semantica dinamica, los siguientes metodos de especificacion...\n    I. Semantica Operacional: Significado ha de ser establecido especificando los efectos de una ejecucion\n    II. Semantica Denotacional: Significado se denota mediante sentencias explicitas que denotan el efecto de la computacion\n    III. Semantica Axiomatica: Especifica propiedades de los efectos de afirmaciones logicas.\n    \nCuales son verdad?\na. Solo II\nb. Solo III\nc. Solo I y II\nd. Solo I y III\ne. Solo II y III\n\n",
            "respuesta": "d",
            "explicacion": " La II no se denota mediante sentencias explicitas, si no mediante objetos matematicos",
            "referencia": "Original",
            "id": 1022,
            "intAnswers": 5
        },
        {
            "pregunta": "\n\nCual de las siguientes alternativas corresponde al orden correcto del proceso de compilacion?\na. Programa fuente -> Analisis Sintactico -> Analisis Semantico -> Analisis Lexico -> Generacion del codigo -> Programa\nb. Programa fuente -> Analisis Semantico  -> Analisis Sintactico -> Analisis Lexico -> Generacion del codigo -> Programa\nc. Programa fuente -> Analisis Lexico -> Analisis Sintactico -> Analisis Semantico -> Generacion del codigo -> Programa\nd. Ninguna de las anteriores esta correcta, puesto que no existe el analisis semantico\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1023,
            "intAnswers": 4
        },
        {
            "pregunta": "\n\nCon respecto a la jerarquia de Chomsky: Cual es el orden correcto de los lenguajes considerando de menor a mayor su tipo?\na. Recursivamente Enumerables -> Sensibles al contextos -> Lenguajes regulares -> Independientes del contextos\nb. Recursivamente Enumerables -> Sensibles al contexto -> Independientes de Contexto -> Lenguajes regulares\nc. Sensibles al contexto -> Recursivamente enumerables -> Lenguajes regulares -> Independientes del contextos\nd. Sensibles al contexto -> Recursivamente enumerables -> Independientes de Contexto -> Lenguajes regulares\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1024,
            "intAnswers": 4
        },
        {
            "pregunta": "\n\nConsidere la siguiente gramatica libre de contexto:\n\n    A -> X|Y\n    aX -> aX|Z\n    Y -> A|X|bb\n    \nCuales es el problema de esta gramatica?\na. Esta mal escrita puesto que posee un simbolo terminal en la parte de no terminales\nb. No esta definido la 4-tupla, por lo que no puede ser definida correctamente\nc. No tiene simbolo de partida S, el cual si o si debe ser este simbolo\nd. Esta fea\n\n",
            "respuesta": "a",
            "explicacion": " Si pusiste la d, que problema tienes con esta gramatica...",
            "referencia": "Original",
            "id": 1025,
            "intAnswers": 4
        },
        {
            "pregunta": "\n\nCaracteristicas de la Backus-Naur Form (BNF) son...\n    I. Lado izquierdo es un simbolo terminal, mientras derecho corresponde a un no terminal\n    II. La expresion \"|\" indica alternar entre opciones\n    III. La ultima regla corresponde siempre a la que terminara la expresion\n    IV. Los parentesis permiten agrupar elementos\n    \na. Solo II\nb. Solo I y II\nc. Solo II y IV\nd. Solo II, III y IV\n\n",
            "respuesta": "a",
            "explicacion": " I: Derecho puede ser o no un terminal. III. No necesariamente IV. Corresponde a EBNF, no BNF.",
            "referencia": "Original",
            "id": 1026,
            "intAnswers": 4
        },
        {
            "pregunta": "\n\nCaracteristicas de la extended Backus-Naur Form (eBNF) son...\n    I. Lado izquierdo es un simbolo no terminal, mientras derecho corresponde a un terminal\n    II. Elementos opcionales son aquellos que se encuentran dentro parentesis cuadrados []\n    III. La llave {x} indica que la palabra a repetirse x veces, con x entre 1 o mas\n    IV. Los parentesis permiten agrupar elementos\n\na. Solo I y II\nb. Solo I y IV\nc. Solo II y IV\nd. Solo I, II y IV\n\n",
            "respuesta": "c",
            "explicacion": " I. Derecho no necesariamente a de ser terminal. III. La llave puede ser 0",
            "referencia": "Original",
            "id": 1027,
            "intAnswers": 4
        },
        {
            "pregunta": "\n\nCuales de los siguientes no son definidos como tipos de tokens?\n    I. Palabras claves reservadas\n    II. Literales y constantes\n    III. Identificadores\n    IV. Simbolos de Operadores\n    V. Comentarios\n\na. Solo II\nb. Solo III\nc. Solo IV\nd. Solo II y IV\ne. Ninguno esta mal definido\nf. Todos estan mal definidos\n\n",
            "respuesta": "e",
            "explicacion": "No explicacion entregada",
            "referencia": "Original",
            "id": 1028,
            "intAnswers": 6
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P7",
            "pregunta": "A partir de las siguientes reglas de precedencia para operadores:\n\nMayor Precedencia   , /, not\n                    +, &, mod\n                    -, -                     =, /=, <, <=, >=, >\n                    and\nMenor Precedencia   or, xor\n\nY considerando asociatividad de izquierda a derecha, \u00c2\u00bfcu\u00c3\u00a1l es el orden correcto de evaluaci\u00c3\u00b3n de la expresi\u00c3\u00b3n: a * b \u00e2\u20ac\u201c 1 + c?\nSeleccione una:\na. ((a * b )1 \u00e2\u20ac\u201c (1 + c)2 )3\nb. c. (((a * b )1 - 1)2 + c)3\nd. \n*Los numeros son el orden en la cual  se evalua la expresion que tiene a la izquierda en parentsis*\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1029,
            "intAnswers": 4
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P12",
            "pregunta": "\nTomar en cuenta el siguiente programa, escrito en sintaxis tipo Javascript:\n\n    // main\n    var x, y, z;\n    function sub1() {\n        var a, y, z;\n        \u00e2\u20ac\u00a6\n    }\n    function sub2() {\n        var a, b, z;\n        \u00e2\u20ac\u00a6\n    }\n    function sub3() {\n        var a, x, w;\n        \u00e2\u20ac\u00a6\n    }\n\nDada la siguiente secuencia de llamadas en un \u00c3\u00a1mbito din\u00c3\u00a1mico: main --> sub1() --> sub3() --> sub2(), \u00c2\u00bfcu\u00c3\u00a1les\nson todas las variables visibles durante la ejecuci\u00c3\u00b3n de sub2()?\n\na. a local, b local, x de main, y de sub1(), z local\nb. a local, b local, x de main, y de main, z local\nc. a local, b local, z local\nd. a local, b local, w de sub3(), x de sub3(), y de sub1(), z local\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1030,
            "intAnswers": 4
        },
        {
            "referencia": "[2021-2] - Mart\u00c3\u00ad Q1P14 - PREGUNTA ADAPTADA",
            "pregunta": "\nDada la siguiente BNF:\n\n    Sentencia :: = ( [Operador] Sentencia [Expresion] ) | Constante | Reservada\n    Expresion :: = Sentencia |     Operador :: = + | *\n    Constante :: = 0 | 1 | 2 | 3 | 4 | 5\n    Reservada :: = if | else | while\n\n\u00c2\u00bfCu\u00c3\u00a1les de las siguientes expresiones no son v\u00c3\u00a1lidas para esta gram\u00c3\u00a1tica?\n\nI)   II)  (* (0 1 +)) \nIII) IV)  \na. Solo I\nb. Solo II\nc. Solo III\nd. Solo IV\nd. I, II y III\ne. II, III y IV\n",
            "respuesta": "e",
            "explicacion": "No explicacion entregada",
            "id": 1031,
            "intAnswers": 5
        },
        {
            "referencia": "[2022-1] - Rodrigo S.  Q1P6",
            "pregunta": "\nDado el siguiente EBNF\n\n    <inicio> ::= <variable> = <expresion>\n    <variable> ::= x|y|z\n    <expresion> ::= <expresion> @ <termino> | <termino>\n    <termino> ::= <termino> # <expresion> | <variable>\n\n\u00c2\u00bfCu\u00c3\u00a1l de las siguientes expresiones no es v\u00c3\u00a1lida para la gram\u00c3\u00a1tica?\n\na. todas son v\u00c3\u00a1lidas\nb. x = x@y#z \nc. z = x@y@z#z\nd. y = y#z@x\n\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1032,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Rodrigo S.  Q1P12",
            "pregunta": "\nLa siguiente BNF genera \u00c3\u00a1rboles sint\u00c3\u00a1cticos ambiguos:\n\n    <inicio> ::= <variable> = <expresion>\n    <variable> ::= x|y|z\n    <expresion> ::= <expresion> @ <termino> | <termino>\n    <termino> ::= <termino> # <expresion> | <variable>\n\nSeleccione la respuesta correcta:\n\na. Falso, el # tiene mayor precedencia que el @\nb. Verdadero\nc. Falso, el @ tiene mayor precedencia que el # \n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1033,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Rodrigo S.  Q1P14",
            "pregunta": "\nLa secuencia principal de compilaci\u00c3\u00b3n de un programa es la siguiente:\n\na. Programa fuente, Generador de c\u00c3\u00b3digo intermedio, analizador l\u00c3\u00a9xico, analizador sint\u00c3\u00a1ctico, Generador de C\u00c3\u00b3digo, Lenguaje de M\u00c3\u00a1quina.\nb. Programa fuente, analizados sem\u00c3\u00a1ntico, analizador sint\u00c3\u00a1ctico, Generador de c\u00c3\u00b3digo y analizador l\u00c3\u00a9xico, Lenguaje de M\u00c3\u00a1quina.\nc. Programa fuente, analizados l\u00c3\u00a9xico, analizador sint\u00c3\u00a1ctico, Generador de c\u00c3\u00b3digo intermedio y analizador sem\u00c3\u00a1ntico, Generador de C\u00c3\u00b3digo, Lenguaje de M\u00c3\u00a1quina.\nd. Programa fuente, analizados l\u00c3\u00a9xico, analizador sem\u00c3\u00a1ntico, Generador de c\u00c3\u00b3digo intermedio y analizador sint\u00c3\u00a1ctico, Generador de C\u00c3\u00b3digo, Lenguaje de M\u00c3\u00a1quina.\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1034,
            "intAnswers": 4
        },
        {
            "referencia": "[2022-1] - Rodrigo S.  Q1P15",
            "pregunta": "\nLos lenguajes de programaci\u00c3\u00b3n pueden ser categorizado acorde a uno de los siguientes paradigmas:\n\na. Puede ser s\u00c3\u00b3lo Imperativo o Funcional\nb. Puede ser s\u00c3\u00b3lo Imperativo, o funcional, o declarativo, u orientado a objetos. \nc. Puede incorporar m\u00c3\u00baltiples paradigmas\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1035,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Wladimir O.  Q1P1",
            "pregunta": "\nConsidere una gr\u00c3\u00a1m\u00c3\u00a1tica libre de contexto definida en base a los siguientes elementos:\n\nV: X,Y,Z\n\u00ce\u00a3: a,b,c\nS: X\n        X  \u00e2\u2020\u2019 Y|Z\n        aX \u00e2\u2020\u2019 Z\n        Z  \u00e2\u2020\u2019 \u00cf\u00b5\n        Y  \u00e2\u2020\u2019 aX|bZ|cZ\n\nIndique la alternativa correcta:\n\na. Estamos en presencia de eBNF en realidad. \nb. Las reglas de producci\u00c3\u00b3n indicadas en  son m\u00c3\u00a1s bien expresiones regulares. \nc. No es en realidad una gr\u00c3\u00a1matica libre de contexto. \nd.  es el conjunto de s\u00c3\u00admbolos no terminales. \ne. Ninguna de las alternativas es correcta.\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1036,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Wladimir O.  Q1P2",
            "pregunta": "\nEn base al siguiente fragmento de c\u00c3\u00b3digo escrito en C++:\n\n    extern int x; \n    int y; \n    int z = 0; \n\nIndique la alternativa correcta:\n\na. \"x\", \"y\" y \"z\" est\u00c3\u00a1n declaradas, pero solo \"z\" esta definida. \nb. \"x\", \"y\" y \"z\" est\u00c3\u00a1n definidas, pero solo \"z\" esta declarada. \nc. \"x\" y \"y\" est\u00c3\u00a1n declaradas, y solo \"z\" esta definida. \nd. \"x\", \"y\" y \"z\" est\u00c3\u00a1n declaradas, pero solo \"y\" y \"z\" estan definidas. \ne. Ninguna de las alternativas es correcta.\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1037,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Wladimir O.  Q1P3",
            "pregunta": "\nEn base al siguiente fragmento de c\u00c3\u00b3digo escrito en C++:\n\n    void funcion1(){ \n    static double x = 0; \n    x = x + 1; \n    cout <<\"x: \"<< x <<endl; \n    }; \n\nLa \"x\" variable  es de tipo:\n\na. Din\u00c3\u00a1mica de stack, y solo visible dentro de la funci\u00c3\u00b3n. \nb. Din\u00c3\u00a1mica de stack, y visible desde fuera de la funci\u00c3\u00b3n. \nc. Din\u00c3\u00a1mica de heap, y visible desde fuera de la funci\u00c3\u00b3n. \nd. Est\u00c3\u00a1tica, y visible desde fuera de la funci\u00c3\u00b3n. \ne. Est\u00c3\u00a1tica, y solo visible dentro de la funci\u00c3\u00b3n.\n",
            "respuesta": "e",
            "explicacion": "No explicacion entregada",
            "id": 1038,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Wladimir O.  Q1P5",
            "pregunta": "\nSobre las variables est\u00c3\u00a1ticas, es incorrecto afirmar que: \n\na. Son escencialmente \u00c3\u00batiles para implementar recursi\u00c3\u00b3n. \nb. Su memoria no se reasigna durante todo el tiempo de ejecuci\u00c3\u00b3n. \nc. Se pueden utilizar en diferentes \u00c3\u00a1mbitos. \nd. En C++ se indican utilizando static. \ne. Todas las afirmaciones son correctas.\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1039,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P11",
            "pregunta": "\nCual de los siguientes no corresponde a un paradigma de la programacion?\na. Imperativo\nb. Estatico\nc. Orientado a objeto\nd. Logico\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1040,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P12",
            "pregunta": "\nCual de los conceptos siguientes no esta definido como corresponde?\na. Semantica: Estudio del significado de los signos linguistiscos y de sus combinaciones\nb. Lenguaje (formal): Conjunto de reglas que definen las secuencias correctas de los elementos de un lenguaje de programacion\nc. Alfabeto: Conjunto de simbolos, letras o tokens con el cual se puede formar la cadena de un lenguaje.\nd. Gramatica (formal): Estructura matematica con un conjunto de reglas de formacion que definen las cadenas de caracteres admisibles en un determinado lenguaje formal\n\n",
            "respuesta": "b",
            "explicacion": "No explicacion entregada",
            "id": 1041,
            "intAnswers": 5
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P13",
            "pregunta": "\nCual de los siguientes casos no se hace uso de la memoria estatica?\na. Variable definida con el modificador sintactico\nb. Variable local compartida\nc. Parametro\nd. Variable global\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1042,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P14",
            "pregunta": "A partir de las siguientes reglas de precedencia para operadores:\n\nMayor Precedencia   , /, not\n                    +, -, -                    -, -                     =, /=, <, <=, >=, >\n                    and\nMenor Precedencia   or, xor\n\nY considerando asociatividad de derecha a izquierda, \u00c2\u00bfcu\u00c3\u00a1l es el orden correcto de evaluaci\u00c3\u00b3n de la expresi\u00c3\u00b3n: a b \u00e2\u20ac\u201c 1 + c?\nSeleccione una:\na. ((a * b ){1} \u00e2\u20ac\u201c (1 + c){2} ){3}\nb. (((a * (b-1) {1} ) {2} ) + c){3}\nc. d. (((a * b){1} - 1){2} + c){3}\n\nLos numeros con {} son el orden en la cual  se evalua la expresion que tiene a la izquierda en parentsis\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1043,
            "intAnswers": 4
        },
        {
            "referencia": "[2024-2] - Jose Luis Marti. Q1P15",
            "pregunta": "\n\nConsidere la siguiente funcion en C, es cierto que...\n\n    char f    {\n        static int b = 0;\n        int c = strlen(a);\n        char d = malloc(c - b++);\n\n        return d ? strcpy(d, a+b) : NULL;\n    }\n\na. c es una variable de stack y a una de heap\nb. b es una variable estatica y d una de heap\nc. c es una variable de heap y a una de heap\nd. c es una variable de stack yd una de heap\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1044,
            "intAnswers": 4
        },
        {
            "pregunta": "\n([2021-x]  Jose Luis Marti C1P21) \nCual de los siguientes lenguajes no es fuertemente tipado?\na. Pascal\nb. Java\nc. Prolog\nd. Python\n\n",
            "respuesta": "c",
            "explicacion": "No explicacion entregada",
            "id": 1045,
            "intAnswers": 4
        },
        {
            "pregunta": "\n([2021-x]  Jose Luis Marti C1P22) \nCual de los siguientes lenguajes usa comprobacion de tipos estatica?\na. C\nb. Scheme\nc. Perl\nd. Python\n\n",
            "respuesta": "a",
            "explicacion": "No explicacion entregada",
            "id": 1046,
            "intAnswers": 4
        },
        {
            "referencia": "enfoque impaciente",
            "pregunta": "\n([2021]  Jose Luis Marti C1P23) \nQue mecanismo de recoleccion de basura se debe implantar en un lenguaje de programacion donde todo el ligado de memoria es estatico o dinamico de stack?\na. Basado en contadores de referencias b. Basado en marcas y barrido c. Una combinacion de ambos, un esquema para la memoria estatica y el otro para el stack\nd. Ninguna de las anteriores\n\n",
            "respuesta": "d",
            "explicacion": "No explicacion entregada",
            "id": 1047,
            "intAnswers": 4
        }
    ]
}